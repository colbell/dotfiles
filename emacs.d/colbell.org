#+TITLE:   Emacs Configuration File
#+AUTHOR:  Colin Noel Bell
#+EMAIL:   col@baibell.org
#+OPTIONS: toc:5 h:5
#+OPTIONS: html-link-use-abs-url:nil html-postamble:auto html-preamble:t
#+OPTIONS: html-scripts:t html-style:t html5-fancy:nil tex:t
#+HTML_CONTAINER: div
#+HTML_DOCTYPE: xhtml-strict
#+HTML_HEAD_EXTRA: Emacs Configuration as pretty HTML. See <tt>~/.emacs.d/colbell.org</tt> for the actual configuration source.
#+INFOJS_OPT: view:info toc:5
#+PROPERTY: header-args :results silent

* Introduction

#+begin_quote
Emacs outshines all other editing software in approximately the same
way that the noonday sun does the stars. It is not just bigger and
brighter; it simply makes everything else vanish.

-- Neal Stephenson, "[[http://www.cryptonomicon.com/beginning.html][In the Beginning was the Command Line]]"
#+end_quote

I've converted my Emacs configuration to an [[http://www.orgmode.org][org-mode]] file which
can be loaded using =(org-babel-load-file /path/to/file)=.
The original inspiration came from a blog post by [[http://sachachua.com/blog/2012/06/literate-programming-emacs-configuration-file/][Sacha Chua]].

I'm also using [[https://github.com/jwiegley/use-package][use-package]] to simplify package handing.

* Editing warning

Place a warning in the generated .el file.

#+begin_src emacs-lisp
;;; -----------------------------------------------
;;; Do not edit this file, as it has been generated
;;; from an Orgmode file. If you do all changes will
;;; be lost when it is next generated on Emacs restart.
;;;
;;; Source: ~/.emacs.d/colbell.org
;;; -----------------------------------------------
#+end_src
* Installing EMACS

I build Emacs from source on Linux.

#+begin_src sh
git clone git://git.savannah.gnu.org/emacs.git
git checkout master             # Bleeding edge
#git checkout emacs-24          # Version 24.
sudo apt-get build-dep emacs24  # Install deps (Debian based distribs only)
./autogen.sh
./configure
make
sudo make install
#+end_src

* Load "Customize" Interface.

Load all settings that were defined through the 'customize' interface.

#+begin_src emacs-lisp
(setq custom-file (expand-file-name "emacs-custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file t))
#+end_src

* Personal information

Me, Myself I.

#+begin_src emacs-lisp
(setq user-full-name "Colin Noel Bell"
      user-mail-address "col@baibell.org")
#+end_src

* Vendor Elisp Directories

Add all vendor libraries to load path. These are libraries that
aren't in any of the package repositories that I use. This is pretty
much empty now that ELPA exists.

#+begin_src emacs-lisp
(defun add-subdirs-to-load-path(parent-dir)
  "Add first level subdirectories in parent-dir to load path."
  (dolist (f (directory-files parent-dir))
    (let ((name (concat parent-dir "/" f)))
      (when (and (file-directory-p name)
                 (not (equal f ".."))
                 (not (equal f ".")))
        (add-to-list 'load-path name)))))

(add-to-list 'load-path (expand-file-name "vendor" user-emacs-directory ))
(add-subdirs-to-load-path (expand-file-name "vendor" user-emacs-directory))
#+end_src

* Paradox

Paradox is a powerful UI for the package manager.

#+begin_src emacs-lisp
(use-package paradox
  :ensure t
  :defer t

  :config
  (progn
    (setq paradox-github-token t)  ;; Don't ask for Github integration.
    (setq paradox-display-download-count t)
    (setq paradox-spinner-type 'box-in-circle)
    (setq paradox-execute-asynchronously t)))
#+end_src

* Smart Mode Line

This is needed prior to setting the theme.

#+begin_src emacs-lisp
(use-package smart-mode-line
  :ensure t
  :init
  (progn
    (sml/setup)))
#+end_src

* Theme
** Solarized

#+begin_src emacs-lisp
(use-package solarized-theme
  :ensure t
  :defer t

  :init
  (progn
    (setq solarized-distinct-fringe-background nil)
    (setq solarized-scale-org-headlines nil)
    (setq solarized-use-variable-pitch nil)
    (setq solarized-high-contrast-mode-line nil)))
#+end_src

** Monokai

#+begin_src emacs-lisp
(use-package monokai-theme
  :ensure t
  :defer t

  :init
  (progn
    (setq monokai-use-variable-pitch nil)
    (setq monokai-height-plus-1 1.0)
    (setq monokai-height-plus-2 1.0)
    (setq monokai-height-plus-3 1.0)
    (setq monokai-height-plus-4 1.0)
    (setq monokai-distinct-fringe-background nil)))
#+end_src

** Zenburn

#+begin_src emacs-lisp
(use-package zenburn-theme
  :ensure t
  :defer t)
#+end_src

** Cyberpunk
#+begin_src emacs-lisp
(use-package cyberpunk-theme
  :ensure t
  :defer t)
#+end_src

** Theme Functions

#+begin_src emacs-lisp
(defun cnb/disable-theme ()
  "Disable current theme."
  (interactive)
  (let ((my-enabled-themes custom-enabled-themes))
    (dolist (theme my-enabled-themes) (disable-theme theme))))

(defun cnb/load-theme (theme)
  "Switch to a new theme."
  ;; Some code stolen from Emacs standard 'load-theme'.
  (interactive
   (list
    (intern (completing-read "Load custom theme: "
                             (mapcar 'symbol-name
                                     (custom-available-themes))))))
  (cnb/disable-theme)
  (load-theme theme t))

(bind-key "<f6>"   #'cnb/load-theme)
(bind-key "S-<f6>" #'cnb/disable-theme)
#+end_src

** Lets make Emacs pretty.

#+begin_src emacs-lisp
(cnb/disable-theme)
(load-theme 'monokai t)
#+end_src

* Sensible defaults

Useful in mode-line.

#+begin_src emacs-lisp
(column-number-mode)
(size-indication-mode)
(display-time-mode)
#+end_src

Enable commands disabled by default for novice users.

#+begin_src emacs-lisp
(put 'narrow-to-region 'disabled nil)            ;; ("C-x n n")
(put 'narrow-to-defun 'disabled nil)             ;; ("C-x n d")
(put 'narrow-to-page 'disabled nil)              ;; ("C-x n p")
(put 'downcase-region 'disabled nil)             ;; ("C-x C-l")
(put 'upcase-region 'disabled nil)               ;; ("C-x C-u")
(put 'dired-find-alternate-file 'disabled nil)   ;; 'a' in dired mode
#+end_src

Use UTF-8.

#+begin_src emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(setq-default buffer-file-coding-system 'utf-8)
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+end_src

Lets auto-revert.

#+begin_src emacs-lisp
(global-auto-revert-mode t)
(setq auto-revert-verbose nil)
(setq global-auto-revert-non-file-buffers t)
#+end_src

Single spaces end sentences - not double spaces.

#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
#+end_src

By default truncate long lines.

#+begin_src emacs-lisp
(toggle-truncate-lines 1)
(setq-default truncate-lines t)
#+end_src

Move deleted files to system trash folder.

#+begin_src emacs-lisp
(setq delete-by-moving-to-trash t)
#+end_src

Delete selection when typing.

#+begin_src emacs-lisp
(delete-selection-mode 1)
#+end_src

Don't use tabs, use spaces instead. Default spacing to 2 spaces.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default tab-width 2)
#+end_src

Remove Unnecessary Clutter

#+begin_src emacs-lisp
(setq use-file-dialog nil)
(setq use-dialog-box nil)
#+end_src

Move mouse cursor when text cursor gets too close.

#+begin_src emacs-lisp
(mouse-avoidance-mode 'exile)
#+end_src

Cursor configuration

#+begin_src emacs-lisp
(setq blink-cursor-blinks 0)
(setq-default cursor-type 'bar)
(blink-cursor-mode)
#+end_src

Use a visible bell instead of a beep.

#+begin_src emacs-lisp
(setq visible-bell t)
#+end_src

When re-centering screen (<ctrl l), first put it to top of screen.

#+BEGIN_SRC emacs-lisp
  (setq recenter-positions '(top middle bottom))
#+END_SRC

A decent font.

#+begin_src emacs-lisp
(set-frame-font "Source Code Pro-10" nil t)
;;(set-frame-font "DejaVu Sans Mono-11" nil t)
#+end_src

  Initialize random number generator.

#+begin_src emacs-lisp
  (random t)
#+end_src

* CSV minor mode

This needs to be installed prior to ace-window otherwise it errors
out. This occurs only when installing, not when loading.

#+begin_src emacs-lisp
(use-package csv-mode
  :defer t
  :ensure t)
#+end_src

* Global Key Map

#+begin_src emacs-lisp
;; I use keys that start with C-o for personal mappings.
(global-unset-key "\C-o")

(global-set-key (kbd "<f8> <f1>") 'repeat-complex-command)

(global-set-key (kbd "C-x C-r") (lambda () (interactive) (revert-buffer nil t)))

(global-set-key (kbd "M-=") #'count-words)
#+end_src

When you drag and drop a file into an Emacs buffer open it instead of
inserting it into the current buffer.

#+begin_src emacs-lisp
(define-key global-map [ns-drag-file] 'ns-find-file)
#+end_src

I press these too often

#+begin_src emacs-lisp
  (global-unset-key (kbd "C-z"))
  (global-unset-key (kbd "C-x C-z"))
#+end_src
* General

Init File profiler.

#+begin_src emacs-lisp
(use-package esup
  :ensure esup
  :commands esup
  :defer t)
#+end_src

Add city times to display-time-world and helm-world-time.

#+BEGIN_SRC emacs-lisp
(require 'time)
(add-to-list 'display-time-world-list '("Australia/Sydney" "Sydney"))
(add-to-list 'display-time-world-list '("Australia/Perth" "Perth"))
(add-to-list 'display-time-world-list '("Asia/Shanghai" "China"))
#+END_SRC

When opening files follow all symbolic links.

#+begin_src emacs-lisp
(setq find-file-visit-truename t)
#+end_src

F11 - flash crosshairs at text cursor position.

#+begin_src emacs-lisp
(use-package crosshairs
  :ensure crosshairs
  :commands flash-crosshairs
  :bind (("<f11>" . flash-crosshairs)))
#+end_src

Show line numbers in fringe.

#+begin_src emacs-lisp
(use-package nlinum
  :ensure t

  :config
  (progn
    (global-nlinum-mode)))
#+end_src

Use the hc command to show HTTP response codes

#+begin_src emacs-lisp
(use-package httpcode
  :commands hc
  :ensure httpcode)
#+end_src

Prompt to exit Emacs

#+begin_src emacs-lisp
(setq confirm-kill-emacs 'y-or-n-p)
#+end_src

Open links in appropriate browser.

#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-text-xterm)
(setq browse-url-text-browser "w3m")
#+END_SRC

Always start a new tags list.

#+BEGIN_SRC emacs-lisp
(setq tags-add-tables nil)
#+END_SRC

I've got some TAGS files that are nearly 20MB in size.

#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold 20000000)
#+END_SRC

** Which Function

For coding buffers show the name of the current function in the
mode line.

#+begin_src emacs-lisp
(use-package which-func)
:init
(progn
  (which-function-mode))
#+end_src

** Battery Status

Put the battery status in the mode-line.
#+begin_src emacs-lisp
(use-package battery
  :config
  (progn
    (when
        (and battery-status-function
             (not (string-match-p "N/A"
                                  (battery-format "%B"
                                                  (funcall battery-status-function)))))
      (setq battery-mode-line-format "[%b%p%%%% %t]")
      (display-battery-mode 1))))
#+end_src

* Minibuffer

Give it some room.

#+begin_src emacs-lisp
(setq resize-mini-windows t)
(setq max-mini-window-height 0.33)
#+end_src

Don't let the cursor go into the minibuffer prompt

#+begin_src emacs-lisp
(setq minibuffer-prompt-properties
      (quote (read-only t point-entered minibuffer-avoid-prompt
                        face minibuffer-prompt)))
#+end_src
* White Space

Formatting of white space.

#+begin_src emacs-lisp
(use-package whitespace
  :diminish whitespace-mode
  :diminish global-whitespace-mode

  :init
  (progn
    (setq whitespace-style '(face tabs empty trailing lines-tail))
    (set-default 'show-trailing-whitespace t)
    (setq whitespace-line-column 80)
    (global-whitespace-mode)

    ;; Don't do this as Postgresql text dumps may have trailing tab characters
    ;; for some columns.
    ;;(add-hook 'before-save-hook (lambda() (delete-trailing-whitespace)))

    ;;(setq whitespace-global-modes '(not org-mode paradox-menu-mode term-mode))

    ;; Don't highlight trailing WS in some modes.
    (dolist (hook '(shell-mode-hook compilation-mode-hook diff-mode-hook
                                    cider-repl-mode term-mode-hook
                                    eww-mode-hook completion-list-mode-hook
                                    undo-tree-visualizer-mode-hook
                                    comint-mode-hook))
      (add-hook hook (lambda () (set-variable 'show-trailing-whitespace nil))))))

(use-package shrink-whitespace
  :ensure t
  :bind (("M-SPC" . shrink-whitespace)))
#+end_src

* Find in Repository

Search the current source code repository for a file.

#+begin_src emacs-lisp
(use-package find-file-in-repository
  :ensure find-file-in-repository
  :bind (("C-x f" . find-file-in-repository)))
#+end_src

* Recent Files

Recent Files is a mode that keeps track of files that have been opened.

#+begin_src emacs-lisp
(use-package recentf
  :ensure t
  :defer t

  :config
  (progn
    (setq recentf-save-file
          (file-truename (expand-file-name "recentf" user-emacs-directory)))
    (setq recentf-max-saved-items 250)

    ;; Files that we don't want to remember.
    (setq recentf-exclude '("~$" "/tmp/" "/ssh:"
                            "/sudo:" "/\\.git/.*\\'"
                            "/home/colbell/.jabber-avatars/*"))

    ;; We don't want to remember the recentf database file itself.
    (add-to-list 'recentf-exclude recentf-save-file)

    ;; Files within home that we don't want kept in recent files.
    ;; Because .emacs.d is a symlink to dotfiles/.emacs.d a file can have two
    ;; names so we need to ignore each file twice. The function (file-truename)
    ;; will expand symlinks.
    (let ((exclude-files '("places" ".ido.last" "elpa/**/.*" "emacs.bmk"
                           "url/cookies" "bookmarks")))
      (while exclude-files
        (let ((f (expand-file-name (car exclude-files) user-emacs-directory)))
          (add-to-list 'recentf-exclude f)
          (add-to-list 'recentf-exclude (file-truename f))
          (setq exclude-files (cdr exclude-files))))))

  (recentf-mode))
#+end_src

* Helm

Helm is an interactive completion tool.

#+begin_src emacs-lisp
(use-package helm
  :ensure t
  :defer t
  :diminish helm-mode

  :config
  (progn
    (require 'helm-config)
    (setq helm-candidate-number-limit 250)
    (setq helm-idle-delay 0.0)        ; update fast sources immediately (doesn't).
    (setq helm-input-idle-delay 0.01) ; this actually updates things relatively quickly.
    (setq helm-quick-update t)
    (setq helm-M-x-requires-pattern 0)
    (setq helm-ff-skip-boring-files t)
    (setq enable-recursive-minibuffers t)
    (setq helm-buffers-fuzzy-matching t)
    (setq helm-split-window-in-side-p t)
    (setq helm-ff-file-name-history-use-recentf t)
    (setq helm-buffer-details-flag nil)
    (setq helm-ff-transformer-show-only-basename t)

    (global-set-key (kbd "C-x c o") 'helm-occur)

    (when (executable-find "curl")
      (setq helm-google-suggest-use-curl-p t))

    (defun helm-backspace ()
      "Forward to `backward-delete-char'. On error (read-only), quit without selecting."
      (interactive)
      (condition-case nil
          (backward-delete-char 1)
        (error
         (helm-keyboard-quit))))

    (define-key helm-map (kbd "DEL")   #'helm-backspace)

    ;; Swap C-z and <tab>.
    (define-key helm-map (kbd "<tab>") #'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-z")   #'helm-select-action)

    ;; Make tab work in terminal.
    (define-key helm-map (kbd "C-i")   #'helm-execute-persistent-action)

    ;; Lets see bookmarks in Helm Mini as well.
    (setq helm-mini-default-sources '(helm-source-buffers-list
                                      helm-source-recentf
                                      helm-source-bookmarks
                                      helm-source-buffer-not-found))

    (helm-mode 1))

  :bind (("M-x"                  . helm-M-x)
         ("M-y"                  . helm-show-kill-ring)
         ("C-c f"                . helm-recentf)
         ("C-x b"                . helm-mini)
         ("C-x C-f"              . helm-find-files)
         ("C-h a"                . helm-apropos)
         ("C-x C-i"              . helm-semantic-or-imenu)
         ([remap occur]          . helm-occur)
         ([remap list-buffers]   . helm-buffers-list)
         ([remap dabbrev-expand] . helm-dabbrev)))
#+end_src

** Helm-descbinds

Show current key bindings

#+begin_src emacs-lisp
  (use-package helm-descbinds
    :ensure helm-descbinds
    :bind (("C-h b" . helm-descbinds)))
#+end_src
* Backup Files

Don't clobber symlinks, owner, group etc.

#+begin_src emacs-lisp
(setq backup-by-copying t)
#+end_src

Don't clutter the disk with Emacs save files. Store them in
=~/.emacs.d/backups=.

#+begin_src emacs-lisp
(setq version-control t)
(setq kept-new-versions 6)
(setq kept-old-versions 2)
(setq delete-old-versions t)
(setq backup-directory-alist
      `(("." . ,(expand-file-name
                 (concat user-emacs-directory "backups")))))
(setq vc-make-backup-files t) ;; Make backups of files, even when they're in version control
#+end_src

* Emacs Server

Start Emacs server on first Emacs instance.

#+begin_src emacs-lisp
  (use-package server
    :commands (server-running-p server-start)

    :init
    (progn
      (unless (server-running-p) (server-start))))
      ;;(setenv "EDITOR" "emacsclient")))

#+end_src
* Edit Text Areas in Chrome

  Editing within Chrome. You need the "Edit with Emacs" Chrome plugin
  installed in Chrome.

#+begin_src emacs-lisp
  ;; (use-package edit-server
  ;;   :ensure t
  ;;   :ensure edit-server-htmlize

  ;;   :init
  ;;   (progn
  ;;     (add-hook 'edit-server-start-hook #'edit-server-maybe-dehtmlize-buffer)
  ;;     (add-hook 'edit-server-done-hook  #'edit-server-maybe-htmlize-buffer)
  ;;     (edit-server-start)))
#+end_src

* Auto-correct

#+begin_src emacs-lisp
  (setq abbrev-file-name "~/.emacs.d/abbrev_defs")
  (setq save-abbrevs 'silently)

  (if (file-exists-p abbrev-file-name)
      (quietly-read-abbrev-file))

  ;;(add-hook 'text-mode-hook (lambda () (abbrev-mode 1)))
  (setq-default abbrev-mode t)

  ;; Hide in mode line.
  (diminish 'abbrev-mode)

  ;; From http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html
  (defun cnb/ispell-word-then-abbrev (p)
    "Call `ispell-word'. Then create an abbrev for the correction made.
     With prefix P, create local abbrev. Otherwise it will be global."
    (interactive "P")
    (let ((bef (downcase (or (thing-at-point 'word) ""))) aft)
      ;; Hide the prefix arg from ispell-word
      (let ((current-prefix-arg nil))
        (call-interactively #'ispell-word))
      (setq aft (downcase (or (thing-at-point 'word) "")))
      (unless (string= aft bef)
        (message "\"%s\" now expands to \"%s\" %sally"
                 bef aft (if p "loc" "glob"))
        (define-abbrev
          (if p local-abbrev-table global-abbrev-table)
          bef aft))))

  ;;(global-set-key "\C-oi" #'cnb/ispell-word-then-abbrev)
#+end_src
* Dired

  Open files in external application.

#+begin_src emacs-lisp
  (defun cnb/open-external()
    "Open file associated with current buffer or files marked in dired buffer
  in native application through xdg-open"
    (interactive)
    (let (my_files)
      (if (string-equal major-mode "dired-mode")
          (setq my_files (dired-get-marked-files))
        (setq my_files (list (buffer-file-name))))

      (when my_files
        (dolist (fn my_files)
          (start-process "" nil "xdg-open" fn)))))
#+end_src

  Add some external programs for =! (dired-do-shell-command)=

#+BEGIN_SRC emacs-lisp
(setq dired-guess-shell-alist-user
      '(("\\.pdf\\'" "atril")
        ("\\.tex\\'" "pdflatex")
        ("\\.ods\\'\\|\\.xlsx?\\'\\|\\.docx?\\'\\|\\.csv\\'" "libreoffice")))
#+END_SRC

  Minor mode to enable previewing in a dired buffer.

#+BEGIN_SRC emacs-lisp
  (use-package peep-dired
    :defer t
    :ensure t)
#+END_SRC

  Directory view/editing.

#+begin_src emacs-lisp
(defun cnb/dired-get-size ()
  "Get total size of all marked files."
  ;;  From http://oremacs.com/2015/01/12/dired-file-size/
  (interactive)
  (let ((files (dired-get-marked-files)))
    (with-temp-buffer
      (apply 'call-process "/usr/bin/du" nil t nil "-sch" files)
      (message
       "Size of all marked files: %s"
       (progn
         (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*total$")
         (match-string 1))))))

(defun cnb/dired-back-to-top ()
  "Move to the first file name in the dired buffer"
  (interactive)
  (let (has-omit-mode has-hide-details-mode line-nbr)
    (when (and (boundp 'dired-omit-mode) dired-omit-mode)
      (setq has-omit-mode t))
    (when (and (boundp 'dired-hide-details-mode) dired-hide-details-mode)
      (setq has-hide-details-mode t))
    (cond
     ((and has-omit-mode has-hide-details-mode)
      (setq line-nbr 1))
     (has-omit-mode
      (setq line-nbr 3))
     (has-hide-details-mode
      (setq line-nbr 3))
     (t
      (setq line-nbr 3)))
    (message (number-to-string line-nbr))
    (beginning-of-buffer)
    (dired-next-line line-nbr)))

(defun cnb/old-dired-back-to-top ()
  "Move to the first file name in the dired buffer"
  (interactive)
  (let* (line-nbr)
    (if (and (boundp 'dired-hide-details-mode) dired-hide-details-mode)
        (setq line-nbr 3)
      (setq line-nbr 4))
    (if (and (boundp 'dired-omit-mode) dired-omit-mode)
        (setq line-nbr 2))
    (beginning-of-buffer)
    (dired-next-line line-nbr)))

(defun cnb/dired-jump-to-bottom ()
  "Jump to last file in dired buffer"
  (interactive)
  (end-of-buffer)
  (dired-next-line -1))


(use-package dired
  :config
  (progn
    (setq dired-listing-switches "-alhGv --group-directories-first")
    (setq dired-dwim-target t)
    (setq dired-recursive-copies 'always) ; Don't ask
    (setq dired-recursive-deletes 'top)   ; Ask once
    (setq diredp-hide-details-initially-flag nil)
    (setq dired-deletion-confirmer 'y-or-n-p)

    (when (boundp 'dired-mode-map)
      (define-key dired-mode-map
        (vector 'remap 'beginning-of-buffer) 'cnb/dired-back-to-top)

      (define-key dired-mode-map
        (vector 'remap 'end-of-buffer) 'cnb/dired-jump-to-bottom))))


(use-package dired-x
  :config
  (progn
    ;; Remember -  <C-x><ALT>o to omit hidden files
    (setq dired-omit-files (concat dired-omit-files "\\|^\\..+$"))))

(use-package dired+
  :ensure dired+

  :config
  (progn
    (diredp-toggle-find-file-reuse-dir 1)))

(use-package wdired
  :defer t
  :config
  (progn
    (setq wdired-allow-to-change-permissions t)
    (setq wdired-confirm-overwrite t)))

#+end_src

* Bookmarks
#+begin_src emacs-lisp
  (use-package bookmark
    :defer t
    :ensure bookmark+

    :config
    (progn
      (require 'bookmark+)
      (setq bookmark-save-flag 1) ; Save bookmarks instantly
      (setq bookmark-default-file
            (expand-file-name "emacs.bmk" user-emacs-directory))))
#+end_src

Visual Bookmarks

#+begin_src emacs-lisp
(defun cnb/bm-hook
    (bm-buffer-save-all)
  (bm-repository-save))

(use-package bm
  :ensure bm
  :defer t
  :commands (bm-repository-load bm-buffer-restore bm-buffer-save bm-repository-save bm-buffer-save-all)

  :bind (("C-<f2>" . bm-toggle)
         ("<f2>"   . bm-next)
         ("S-<f2>" . bm-previous))

  :config
  (progn
    (setq bm-restore-repository-on-load t)
    (setq bm-repository-file (expand-file-name "bm-repository" user-emacs-directory))
    (setq bm-repository-size 1024)
    (setq-default bm-buffer-persistence t)
    (setq bm-highlight-style 'bm-highlight-only-line)
    (add-hook 'after-init-hook #'bm-repository-load)
    (add-hook 'find-file-hooks #'bm-buffer-restore)
    (add-hook 'kill-buffer-hook #'bm-buffer-save)
    (add-hook 'kill-emacs-hook (lambda nil
                                 (bm-buffer-save-all)
                                 (bm-repository-save))))
  )
#+end_src

* Spelling

#+begin_src emacs-lisp
(use-package flyspell
  :defer t
  :ensure helm-flyspell
  :diminish flyspell-mode

  :config
  (progn)
  (define-key flyspell-mode-map (kbd "C-;") #'helm-flyspell-correct))
#+end_src

Dictionary Look-up

#+begin_src emacs-lisp
  (use-package helm-words
    :ensure t
    :defer t

    :config
    (progn
      (use-package dictionary
        :ensure t))

    :bind (("C-c d" . helm-words-at-point)
           ("C-c D" . helm-words)))

#+end_src
* Frames

#+begin_src emacs-lisp
(setq frame-title-format '(buffer-file-name "%f" ("%b")))
#+end_src

Toggle Frame Split

#+begin_src emacs-lisp
;; From http://www.emacswiki.org/emacs-en/ToggleWindowSplit
(defun cnb/toggle-frame-split ()
  "If the frame is split vertically, split it horizontally or vice versa .
  Assumes that the frame is only split into two                            . "
  (interactive)
  (unless (= (length (window-list)) 2) (error "Can only toggle a frame split in two"))
  (let ((split-vertically-p (window-combined-p)))
    (delete-window) ; closes current window
    (if split-vertically-p
        (split-window-horizontally)
      (split-window-vertically)) ; gives us a split with the other win twice
    (switch-to-buffer nil))) ; restore the orig  win in this part of the frame

(define-key ctl-x-4-map "t" #'cnb/toggle-frame-split)

#+end_src
* Moving Around
** Move By Visual Lines
#+begin_src emacs-lisp
(setq line-move-visual nil)
#+end_src

** Helm-swoop

This is a quick way to find lines.

#+begin_src emacs-lisp
(use-package helm-swoop
  :ensure helm-swoop
  :config
  (progn
    (setq helm-swoop-speed-or-color t)
    (setq helm-swoop-use-line-number-face t))

  :bind
  ("M-i" . helm-swoop))
#+end_src

** Dragging

Drag mode. Allows dragging by alt left up etc.

#+begin_src emacs-lisp
(use-package drag-stuff
  :ensure drag-stuff
  :diminish drag-stuff-mode

  :config
  (progn
    (setq drag-stuff-except-modes '(org-mode))
    (drag-stuff-global-mode)))

#+end_src

** Go to Last Change

#+begin_src emacs-lisp
  (use-package goto-chg
    :ensure t
    :config
    (progn
      (defalias 'glc 'goto-last-change)))
#+end_src

** Ace Window

Select window by number.

#+begin_src emacs-lisp
(use-package ace-window
  :ensure ace-window
  :bind (("<f7>" . ace-window))

  :init
  (progn
    (setq aw-scope 'frame)
    (setq aw-background t)
    (setq aw-flip-keys '("n")))  ;; 'n' will goto last window in ace-window.
  ;; (setq avy-keys (nconc (loop for i from ?0 to ?9 collect i)
  ;;                       (loop for i from ?a to ?z collect i)
  ;;                       (loop for i from ?A to ?Z collect i)))

  :config
  (progn
    (ace-window-display-mode)))
#+end_src

** Ace Link

Bind 'o' to links in Help and Info buffers
#+begin_src emacs-lisp
  (use-package ace-link
    :ensure ace-link

    :init
    (progn
      (ace-link-setup-default)))
#+end_src

* Buffers
** IBuffer

Diff Two Marked Buffers

#+begin_src emacs-lisp
(defun ibuffer-ediff-marked-buffers ()
  "ediff 2 marked buffers"
  (interactive)
  (let* ((marked-buffers (ibuffer-get-marked-buffers))
         (len (length marked-buffers)))
    (unless (= 2 len)
      (error (format "%s buffer%s been marked (needs to be 2)"
                     len (if (= len 1) " has" "s have"))))
    (ediff-buffers (car marked-buffers) (cadr marked-buffers))))
#+end_src

IBuffer is an advanced replacement for BufferMenu.

#+begin_src emacs-lisp
(use-package ibuffer
  :bind (("C-x C-b" . ibuffer))
  :ensure ibuffer-vc

  :config
  (progn
    (defadvice ibuffer (around ibuffer-point-to-most-recent activate) ()
               "Open ibuffer with cursor at most recently viewed buffer."
               (let ((current-buffer-name (buffer-name)))
                 ad-do-it
                 (ibuffer-jump-to-buffer current-buffer-name)))

    (define-key ibuffer-mode-map "e" #'ibuffer-ediff-marked-buffers)
    ;;(setq ibuffer-default-sorting-mode 'alphabetic)


    (add-hook 'ibuffer-hook
              (lambda ()
                (ibuffer-auto-mode)
                (ibuffer-vc-set-filter-groups-by-vc-root)
                (unless (eq ibuffer-sorting-mode 'alphabetic)
                  (ibuffer-do-sort-by-alphabetic))
                (visual-line-mode -1)))

    ;; Replace the filename filter with a file name/directory name filter
    (eval-after-load "ibuf-ext"
      '(define-ibuffer-filter filename
           "Toggle current view to buffers with file or directory name matching QUALIFIER."
         (:description "filename"
                       :reader (read-from-minibuffer "Filter by file/directory name (regexp): "))
         (ibuffer-awhen (or (buffer-local-value 'buffer-file-name buf)
                            (buffer-local-value 'dired-directory buf))
                        (string-match qualifier it)))))

  :init
  (progn
    (setq ibuffer-expert t) ;; Don't prompt closing unmodified buffers
    (setq ibuffer-show-empty-filter-groups nil)

    (setq ibuffer-formats
          '((mark modified read-only" "
                  (name 30 30 :left :elide)
                  " "
                  (size 9 -1 :right)
                  " "
                  (mode 16 16 :left :elide)
                  " "
                  (vc-status 16 16 :left)
                  " "
                  filename-and-process)
            (mark vc-status-mini " "
                  (name 16 -1)
                  " " filename)))))

#+end_src

** Unique Buffer Names
#+begin_src emacs-lisp
(use-package uniquify
  :init
  (progn
    (setq uniquify-buffer-name-style 'post-forward-angle-brackets)
    (setq uniquify-after-kill-buffer-p t)
    (setq uniquify-ignore-buffers-re "^\\*")))
#+end_src

** Midnight Mode

Close buffers that haven't been used in =clean-buffer-list-delay-general= days.

#+begin_src emacs-lisp
  (use-package midnight
    :init
    (progn
      (setq clean-buffer-list-delay-general 2)))
#+end_src

** Saving

Flag script files as executable on save.

#+begin_src emacs-lisp
  (add-hook
   'after-save-hook
   #'executable-make-buffer-file-executable-if-script-p)
#+end_src

Automatically save buffers when losing focus.

#+begin_src emacs-lisp
  (defun cnb/save-buffers ()
    "When you shift focus to a non-Emacs window save all buffers."
    (interactive)
    (save-some-buffers t))

  (add-hook 'focus-out-hook #'cnb/save-buffers)
#+end_src

** ANSI Colors
#+BEGIN_SRC emacs-lisp
  (defun cnb/ansi-color-apply-buffer ()
    "interactive function that renders buffer using ANSI colors"
    (interactive)
    (ansi-color-apply-on-region (point-min) (point-max)))
#+END_SRC
* Windows
** Winner Mode

C-c left/right to undo/redo window configuration changes.

#+begin_src emacs-lisp
(use-package winner
  :init
  (progn
    (winner-mode)))
#+end_src

** Rotate Windows
#+begin_src emacs-lisp
(defun cnb/rotate-windows ()
  "Rotate your windows" (interactive)
  (cond ((not (> (count-windows) 1)) (message "You can't rotate a single window!"))
        (t
         (setq i 1)
         (setq numWindows (count-windows))
         (while  (< i numWindows)
           (let* (
                  (w1 (elt (window-list) i))
                  (w2 (elt (window-list) (+ (% i numWindows) 1)))
                  (b1 (window-buffer w1))
                  (b2 (window-buffer w2))
                  (s1 (window-start w1))
                  (s2 (window-start w2))
                  )
             (set-window-buffer w1  b2)
             (set-window-buffer w2 b1)
             (set-window-start w1 s2)
             (set-window-start w2 s1)
             (setq i (1+ i)))))))

(global-set-key (kbd "M-r") 'cnb/rotate-windows)
#+end_src
** PopWin

#+begin_src emacs-lisp
    (use-package popwin
      :ensure t

      :init
      (progn
        (require 'popwin)
        (popwin-mode 1)))
#+end_src

** Positioning

   Function to Close side window at the bottom.

#+BEGIN_SRC emacs-lisp
  (defun cnb/quit-bottom-side-windows ()
    "Quit side windows at bottom of frame and bury its buffer"
    (interactive)
    (dolist (win (window-at-side-list))
      (quit-window nil win)))

  (global-set-key (kbd "C-c q") #'cnb/quit-bottom-side-windows)
#+END_SRC

   Position some windows in side window at bottom of frame.

#+BEGIN_SRC emacs-lisp
(add-to-list
 'display-buffer-alist
 `(,(rx bos "*Flycheck errors*" eos)
   (display-buffer-reuse-window display-buffer-in-side-window)

   (reusable-frames . t)
   (side            . bottom)
   (window-height   . 0.4)))

(add-to-list
 'display-buffer-alist
 `(,(rx bos "*rspec-compilation*" eos)
   (display-buffer-reuse-window display-buffer-in-side-window)
   (reusable-frames . t)
   (side            . bottom)
   (window-height   . 0.4)))

(add-to-list
 'display-buffer-alist
 `(,(rx bos "*ruby*" eos)
   (display-buffer-reuse-window display-buffer-in-side-window)
   (reusable-frames . t)
   (side            . bottom)
   (window-height   . 0.4)))

(add-to-list
 'display-buffer-alist
 `(,"\\*rails.*-log*"
   (display-buffer-reuse-window display-buffer-in-side-window)
   (reusable-frames . t)
   (side            . bottom)
   (window-height   . 0.4)))

(add-to-list
 'display-buffer-alist
 '("\\`\\*helm.*\\*\\'"
   (display-buffer-in-side-window)
   (inhibit-same-window . t)
   (window-height . 0.4)))


;; This MUST be after the general helm case otherwise it won't be used
;; and the helm help buffer will not be displayed.
(add-to-list
 'display-buffer-alist
 '("*.*Helm.*Help.**"))

#+END_SRC

#+BEGIN_SRC emacs-lisp
#+END_SRC
* Selection

Shift/arrow keys extend selection.

#+begin_src emacs-lisp
(setq shift-select-mode nil)
#+end_src

Smart selection.

#+begin_src emacs-lisp
(use-package expand-region
  :ensure expand-region
  :bind (("C-=" . er/expand-region)))
#+end_src

* Multiple Cursors
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :ensure t
  :defer t

  :bind (("C-c m t" . mc/mark-all-like-this)
         ("C-c m m" . mc/mark-all-like-this-dwim)
         ("C-c m l" . mc/edit-lines)
         ("C-c m e" . mc/edit-ends-of-lines)
         ("C-c m a" . mc/edit-beginnings-of-lines)
         ("C-c m n" . mc/mark-next-like-this)
         ("C-c m p" . mc/mark-previous-like-this)
         ("C-c m s" . mc/mark-sgml-tag-pair)
         ("C-c m d" . mc/mark-all-like-this-in-defun)))
#+END_SRC

* Copying, Killing and Moving
** Kill ring Integration
#+begin_src emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+end_src

** Browse kill ring

#+begin_src emacs-lisp
  (use-package browse-kill-ring
    :ensure browse-kill-ring
    :defer t

    :config
    (progn
      ;;(browse-kill-ring-default-keybindings)
      (setq browse-kill-ring-highlight-current-entry t)
      (setq browse-kill-ring-no-duplicates t)
      (setq browse-kill-ring-display-duplicates nil)
      (setq browse-kill-ring-highlight-inserted-item nil)
      (setq browse-kill-ring-show-preview nil)
      (setq browse-kill-ring-quit-action 'save-and-restore)))
#+end_src

** Undo Tree
#+begin_src emacs-lisp
  (use-package undo-tree
    :ensure undo-tree
    :diminish undo-tree-mode

    :config
    (global-undo-tree-mode)
    (progn
      ;; Keep region when undoing in region.
      (defadvice undo-tree-undo (around keep-region activate)
        (if (use-region-p)
            (let ((m (set-marker (make-marker) (mark)))
                  (p (set-marker (make-marker) (point))))
              ad-do-it
              (goto-char p)
              (set-mark m)
              (set-marker p nil)
              (set-marker m nil))
          ad-do-it))
      )
    )

#+end_src

** Operate on Current Line

#+begin_src emacs-lisp
  (use-package easy-kill
    :ensure t
    :bind (([remap kill-ring-save] . easy-kill)))
#+end_src

If no current selection then let C-W and M-W operate on the current
line. http://www.emacswiki.org/emacs/SlickCopy

#+begin_src emacs-lisp
  ;; (defadvice kill-ring-save (before slick-copy activate compile)
  ;;   "When called interactively with no active region, copy a single line instead."
  ;;   (interactive
  ;;    (if mark-active (list (region-beginning) (region-end))
  ;;      (message "Copied line")
  ;;      (list (line-beginning-position)
  ;;            (line-beginning-position 2)))))

  ;; (defadvice kill-region (before slick-cut activate compile)
  ;;   "When called interactively with no active region, kill a single line instead."
  ;;   (interactive
  ;;    (if mark-active (list (region-beginning) (region-end))
  ;;      (list (line-beginning-position)
  ;;            (line-beginning-position 2)))))
#+end_src

* Search/Replace

** Silver Searcher (ag)

#+begin_src sh
apt-get install silversearcher-ag
#+end_src

#+begin_src emacs-lisp
  (use-package ag
    :ensure t

    :config
    (progn
      (setq ag-highlight-search t)))
#+end_src
** Anzu

For searches display the current match and total matches
information in the mode line.

For search and replace preview the change if using the anzu functions.

#+begin_src emacs-lisp
(use-package anzu
  :ensure anzu
  :diminish anzu-mode

  :bind (("M-%"   . anzu-query-replace)
         ("C-M-%" . anzu-query-replace-regexp))

  :init
  (progn
    (global-anzu-mode)
    (setq anzu-search-threshold 1000)))
#+end_src

* Printing
#+begin_src emacs-lisp
  (require 'printing)
  (pr-update-menus t)

  (setenv "CUPS_SERVER" "localhost")
  (require 'cups nil t)

  (setq ps-printer-name t)

  (defun cnb-print-to-pdf ()
    "Print the current buffer to a PDF"
    (interactive)
    (let ((ps-file (concat (buffer-name) ".ps"))
          (pdf-file (concat (buffer-name) ".pdf")))
      (ps-spool-buffer-with-faces)
      (switch-to-buffer "*PostScript*")
      (write-file ps-file)
      (kill-buffer ps-file)
      (shell-command
       (concat "ps2pdf14 " ps-file " " pdf-file))
      (delete-file ps-file)
      (find-file pdf-file)
      (message (concat "PDF Saved to: " (buffer-name) ".pdf"))))
#+end_src

* Completion
** Hippie Expansion
#+begin_src emacs-lisp
  (use-package hippie-exp
    :init
    (progn
      (setq hippie-expand-try-functions-list
            '(try-complete-file-name-partially
              try-complete-file-name try-expand-all-abbrevs
              try-expand-dabbrev try-expand-dabbrev-all-buffers
              try-expand-dabbrev-from-kill try-complete-lisp-symbol)))
    :bind
    ("M-/" . hippie-expand))
#+end_src

** Company Mode
#+begin_src emacs-lisp
    (use-package company
      :ensure t
      :diminish company-mode

      :init
      (progn
        ;;(push 'company-robe company-backends)
        (global-company-mode 1)
        (setq company-idle-delay 0.5))

      :bind ("C-c i" . company-complete))
#+end_src
* Discover My Major

Discover key bindings and their meaning for the current Emacs major mode.

#+HEADER: :results silent
#+begin_src emacs-lisp
  (use-package discover-my-major
    :ensure discover-my-major
    :bind (("C-h C-m" . discover-my-major))
  )
#+end_src

* Programming Utilities
** Ediff

#+begin_src emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-diff-options "-w")

  (add-hook 'ediff-after-quit-hook-internal 'winner-undo)
#+end_src

** GIT
*** Magit

Magit is a very cool GUI for Git.

#+begin_src emacs-lisp
  ;; (defun cnb/magit-status-mode-hook ()
  ;;   (visual-line-mode -1))

  (use-package magit
    :ensure t
    :bind (("C-c g"   . magit-status)
           ("C-x M-g" . magit-dispatch-popup))

    :config
    (progn
      ;;(setq magit-diff-refine-hunk 'all)
      (setq magit-process-popup-time 30)
      ;;(setq magit-auto-revert-mode t)
      ;;(setq magit-last-seen-setup-instructions "1.4.0")
      (setq magit-completing-read-function #'helm--completing-read-default)
      (setq magit-push-always-verify nil)
      (setq magit-revert-buffers t)
      (setq magit-popup-use-prefix-argument 'default)

      ;;(add-hook 'magit-log-edit-mode-hook #'flyspell-mode)
      (add-hook 'git-commit-mode-hook #'flyspell-mode)
      ;;(add-hook 'magit-status-mode-hook #'cnb/magit-status-mode-hook)
      ))
#+end_src
*** WAITING Git Gutter                                              :WAITING:
   - State "WAITING"       from "TODO"       [2015-04-07 Tue 11:23] \\
     Need to work out the exact problem. It appears that either flycheck or
     nlinum interferes with git-gutter. git-gutter-fringe works if its
     configured to use the right gutter.

Show Git status on each line

Git Gutter doesn't work with flycheck/nlinum.

#+begin_src emacs-lisp
  ;; (use-package git-gutter
  ;;   :ensure t
  ;;   :diminish (git-gutter-mode . "GG")

  ;;   :config
  ;;   (progn
  ;;     ;;(setq git-gutter:lighter " GG")
  ;;     (global-git-gutter-mode t)
  ;;     (git-gutter:linum-setup)))
#+end_src

Git gutter fringe works with Flycheck/nlinum

#+begin_src emacs-lisp
  (use-package git-gutter-fringe
    :ensure t
    :diminish git-gutter-mode

    :config
    (progn
      (global-git-gutter-mode)
      (setq git-gutter-fr:side 'right-fringe)))
#+end_src

*** Git Messenger

Show commit details for the current line.

#+HEADER: :results silent
#+begin_src emacs-lisp
  (defun cnb/git-msg-popup-hook ()
    (magit-commit-mode))

  (use-package git-messenger
    :ensure git-messenger

    :bind (("C-x v p" . git-messenger:popup-message))

    :init
    (progn
      (defun cnb/git-msg-popup-hook ()
        (magit-commit-mode))
      (setq git-messenger:show-detail t)
      (add-hook 'git-messenger:popup-buffer-hook #'cnb/git-msg-popup-hook)))
#+end_src

*** Git Timemachine

Show a file as at a particular commit.

#+begin_src emacs-lisp
    (use-package git-timemachine
      :ensure git-timemachine
      :defer t

      :init
      (progn
        (defalias 'gtm 'git-timemachine)))
#+end_src

*** Git Blame

An interactive, interative 'git blame' mode.

#+begin_src emacs-lisp
    (use-package mo-git-blame
      :ensure t
      :defer t)
#+end_src

** Projectile

Projectile is a Project Interaction Library.

#+begin_src emacs-lisp
;; Projectile doesn't include f but crashes if it isn't there.
;; TODO: Test if this is still a problem.
;; (use-package f
;;   :ensure t
;;   :ensure f

;;   :init
;;   (progn
;;     (require 'f)))

;; Required by projectile.
(use-package projectile
  :ensure t
  :diminish projectile-mode
  :defer t

  :config
  (progn
    ;;(setq projectile-completion-system 'helm)
    (setq projectile-completion-system 'helm-comp-read)
    (setq projectile-switch-project-action 'projectile-dired)
    (setq projectile-enable-caching t)
    (projectile-global-mode)))

(use-package projectile-rails
  :ensure t
  :defer t
  :diminish projectile-rails-mode

  :init
  (progn
    (add-hook 'projectile-mode-hook #'projectile-rails-on)))

#+end_src

#+begin_src emacs-lisp
  (use-package helm-projectile
    :ensure helm-projectile
    :defer t

    :init
    (progn
      (helm-projectile-on)

      (add-to-list 'projectile-rails-resource-name-re-list "/app/authorizers/\\(?:.+/\\)?\\(.+\\)\\.rb\\'")
      (defun cnb/projectile-rails-find-authorizer ()
        (interactive)
        (projectile-rails-find-resource
         "authorizer: "
         '(("app/authorizers/" "/authorizers/\\(.+\\)_authorizer\\.rb$"))
         "app/authorizers/${filename}_authorizer.rb"))

      (defun cnb/projectile-rails-find-current-authorizer ()
        (interactive)
        (projectile-rails-find-current-resource "app/authorizers/"
                                                "/${singular}\\.rb$"
                                                'cnb/projectile-rails-find-authorizer))

      (add-to-list 'projectile-rails-resource-name-re-list "/app/decorators/\\(?:.+/\\)?\\(.+\\)\\.rb\\'")
      (defun cnb/projectile-rails-find-decorator ()
        (interactive)
        (projectile-rails-find-resource
         "decorator: "
         '(("app/decorators/" "/decorators/\\(.+\\)_decorator\\.rb$"))
         "app/decorators/${filename}_decorator.rb"))

      (defun cnb/projectile-rails-find-current-decorator ()
        (interactive)
        (projectile-rails-find-current-resource "app/decorators/"
                                                "/${singular}\\.rb$"
                                                'cnb/projectile-rails-find-decorator))))
#+end_src

** Smart Parens

Deal with parens in a smart way.

#+begin_src emacs-lisp
  (use-package smartparens-config
    :ensure smartparens
    ;;:diminish smartparens

    :config
    (progn
      ;;(require 'smartparens-config nil t)
      ;;(require 'smartparens-html)
      ;;(require 'smartparens-latex)

      (smartparens-global-mode)

      (show-smartparens-global-mode)

      (setq sp-autoescape-string-quote nil) ; Irritating.

      (define-key sp-keymap (kbd "C-M-f") 'sp-forward-sexp)
      (define-key sp-keymap (kbd "C-M-b") 'sp-backward-sexp)

      (define-key sp-keymap (kbd "C-M-d") 'sp-down-sexp)
      (define-key sp-keymap (kbd "C-M-a") 'sp-backward-down-sexp)
      (define-key sp-keymap (kbd "C-S-a") 'sp-beginning-of-sexp)
      (define-key sp-keymap (kbd "C-S-d") 'sp-end-of-sexp)

      (define-key sp-keymap (kbd "C-M-e") 'sp-up-sexp)
      (define-key sp-keymap (kbd "C-M-u") 'sp-backward-up-sexp)
      (define-key sp-keymap (kbd "C-M-t") 'sp-transpose-sexp)

      (define-key sp-keymap (kbd "C-M-n") 'sp-next-sexp)
      (define-key sp-keymap (kbd "C-M-p") 'sp-previous-sexp)

      (define-key sp-keymap (kbd "C-M-k") 'sp-kill-sexp) ;; FIXME: Doesn't work
      (define-key sp-keymap (kbd "C-M-w") 'sp-copy-sexp)

      (sp-with-modes '(html-mode sgml-mode web-mode)
        (sp-local-pair "<" ">"))))
#+end_src

** Snippets
#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure yasnippet
    :diminish yas-minor-mode
    :defer t

    :config
    (progn
      (yas-global-mode 1)))


  (use-package helm-c-yasnippet
    :ensure helm-c-yasnippet
    :defer t
    :bind (("C-c y" . helm-yas-complete)))
#+end_src

** Rainbow Delimiters
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :ensure rainbow-delimiters)
#+end_src
** Diff
#+begin_src emacs-lisp
  ;; Default to unified diffs that ignore white-space.
  (setq diff-switches "-u -w")
#+end_src

** Speed Bar
#+begin_src emacs-lisp
  (use-package sr-speedbar
    :ensure sr-speedbar
    ;;:bind (("C-o s" . sr-speedbar-toggle))

    :init
    (progn
      (setq sr-speedbar-auto-refresh t)
      (setq sr-speedbar-right-side nil)
      (setq sr-speedbar-skip-other-window-p t)
      (setq speedbar-show-unknown-files t)
      (setq speedbar-verbosity-level 2)))

#+end_src

** Rainbow Mode

Colorize strings that represent colors.

#+begin_src emacs-lisp
(use-package rainbow-mode
  :ensure rainbow-mode
  :init
  (progn
    (setq rainbow-html-colors t)
    (setq rainbow-x-colors t)))
#+end_src
** Color Identifiers Mode

Uniquely highlight each source code identifier based on its name.

#+begin_src emacs-lisp
  (use-package color-identifiers-mode
    :ensure color-identifiers-mode
    :diminish color-identifiers-mode
    :commands global-color-identifiers-mode

    :config
    (progn
      ;; Treat Web mode the same as HTML mode.
      (add-to-list
       'color-identifiers:modes-alist
       `(web-mode . ("</?!?"
                     "\\_</?!?\\([a-zA-Z_$]\\(?:\\s_\\|\\sw\\)*\\)"
                     (nil font-lock-function-name-face))))
      (add-hook 'after-init-hook #'global-color-identifiers-mode)))

#+end_src

** Eldoc

Show min ibuffer hints for Emacs Lisp.
#+begin_src emacs-lisp
  (use-package "eldoc"
    :diminish eldoc-mode
    :commands eldoc-mode

    :init
    (progn
    (add-hook #'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    (add-hook #'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
    (add-hook #'ielm-mode-hook 'turn-on-eldoc-mode)))
#+end_src

** Bug Reference

Turn references to bug IDs into clickable links.

#+begin_src emacs-lisp
  (use-package bug-reference
    :demand

    :init
    (progn
      (add-hook #'text-mode-hook #'bug-reference-mode)
      (add-hook #'magit-log-mode-hook #'bug-reference-mode)
      ;; Force Magit log mode to load .dir-locals.el.
      (add-hook #'magit-log-mode-hook #'hack-dir-local-variables-non-file-buffer)
      (add-hook #'prog-mode-hook #'bug-reference-prog-mode)))
#+end_src

Add a .dir-locals.el to the root of the repository defining the link format and
the bug repository. E.G the following will point TWEB-???? references to Jira.

#+begin_src emacs-lisp[:eval never]
  ((nil
    .
    ((bug-reference-url-format . "https://kwelasolutions.atlassian.net/browse/%s")
     (bug-reference-bug-regexp . "\\(?2:TWEB-[0-9]+\\)"))))
#+end_src

** Flycheck
#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :ensure flycheck-pos-tip

    :init
    (progn
      (setq flycheck-indication-mode 'left-fringe)
      (add-hook 'after-init-hook #'global-flycheck-mode))

    :config
    (progn
      (setq flycheck-display-errors-function #'flycheck-pos-tip-error-messages)))
#+end_src

** Coding Hook

Based on Emacs Starter Kit. Some standard functionality for coding buffers.
#+begin_src emacs-lisp
  (defvar cnb/coding-hook nil
    "Hook that gets run on activation of any programming mode.")

  (defun cnb/add-watchwords ()
    "Tedxt to be emphaised in comments."
    (font-lock-add-keywords
     nil '(("\\<\\(FIX\\|TODO\\|FIXME\\|HACK\\|REFACTOR\\):"
            1 font-lock-warning-face t))))

  (defun cnb/run-coding-hook ()
    "Enable things that are convenient across all coding buffers."
    (run-hooks 'cnb/coding-hook))


  ;;=======================
  ;; Things to do when you open a coding buffer.
  ;;=======================
  (add-hook 'cnb/coding-hook #'cnb/add-watchwords)
  (add-hook 'cnb/coding-hook #'hs-minor-mode)
  (add-hook 'cnb/coding-hook #'subword-mode)
  (add-hook 'cnb/coding-hook #'flyspell-prog-mode)
  ;; (add-hook 'cnb/coding-hook #'nlinum-mode)
  (add-hook 'cnb/coding-hook #'outline-minor-mode)

  (when (fboundp 'yas/minor-mode)
    (add-hook 'cnb/coding-hook #'yas/minor-mode))

  (when (fboundp 'rainbow-delimiters-mode)
    (add-hook 'cnb/coding-hook #'rainbow-delimiters-mode))


  ;;=======================
  ;; Modes to treat as coding buffers
  ;;=======================
  (add-hook 'prog-mode-hook        #'cnb/run-coding-hook)
  (add-hook 'conf-mode-hook        #'cnb/run-coding-hook)
  (add-hook 'css-mode-hook         #'cnb/run-coding-hook)
  (add-hook 'cucumber-mode-hook    #'cnb/run-coding-hook)
  (add-hook 'diff-hook             #'cnb/run-coding-hook)
  (add-hook 'feature-mode-hook     #'cnb/run-coding-hook)
  (add-hook 'markdown-mode-hook    #'cnb/run-coding-hook)
  (add-hook 'rhtml-mode-hook       #'cnb/run-coding-hook)
  (add-hook 'yaml-mode-hook        #'cnb/run-coding-hook)
  (add-hook 'lisp-interaction-mode #'cnb/run-coding-hook)

#+end_src

* Clojure
** Clojure Mode.

#+begin_src emacs-lisp
  (use-package clojure-mode
    :ensure clojure-mode
    :ensure flycheck-clojure
    :defer t

    :config
    (progn
      (eval-after-load 'flycheck '(flycheck-clojure-setup))
      (add-hook 'clojure-mode-hook #'cider-mode)
      (add-hook 'clojure-mode-hook
                (lambda ()
                  (clj-refactor-mode 1)
                  (cljr-add-keybindings-with-prefix "C-o C-r")))

      (define-key clojure-mode-map (kbd "C-o j") 'cider-jack-in)
      (define-key clojure-mode-map (kbd "C-o J") 'cider-restart)
      (define-key clojure-mode-map (kbd "C-o a") 'align-cljlet)

      (define-clojure-indent
        (defroutes 'defun)
        (GET 2)
        (POST 2)
        (PUT 2)
        (DELETE 2)
        (HEAD 2)
        (ANY 2)
        (context 2)
        (for-all 1)
        (such-that 1)
        (let-routes 1)
        (run-db 2)
        (defspec 'defun))))
#+end_src

Extra font locking for Clojure mode.

#+begin_src emacs-lisp
  (use-package clojure-mode-extra-font-locking
    :ensure clojure-mode-extra-font-locking
    :defer t)
#+end_src

** Cheat Sheet

Clojure documentation.

#+begin_src emacs-lisp
(use-package clojure-cheatsheet
  :ensure clojure-cheatsheet
  :defer t

  :init
  (progn
    (defalias 'ccs 'clojure-cheatsheet)))
#+end_src

** Align let forms
#+begin_src emacs-lisp
(use-package align-cljlet
  :ensure align-cljlet
  :defer t)
#+end_src
** Refactoring
#+begin_src emacs-lisp
  (use-package clj-refactor
    :ensure t
    :defer t
    :diminish clj-refactor-mode)

  ;; Helm interface to clj-refactor
  (use-package cljr-helm
    :ensure t
    :defer t

    :config
    (progn
      (bind-key "C-c r" 'cljr-helm clojure-mode-map)))
#+end_src

** Cider Clojure IDE and REPL

#+begin_src emacs-lisp
  (use-package cider
    :ensure cider
    :defer t

    :init
    (progn
      (defalias 'cveb 'cider-visit-error-buffer)
      (setq nrepl-log-messages t)
      (require 'cider-eldoc)
      (add-hook 'cider-mode-hook #'cider-turn-on-eldoc-mode)
      (add-hook 'cider-repl-mode-hook #'subword-mode)
      (add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode)
      (setq cider-repl-use-clojure-font-lock t)
      (setq nrepl-hide-special-buffers t)
      (setq cider-show-error-buffer nil)
      (setq cider-auto-select-error-buffer nil)
      (setq cider-repl-pop-to-buffer-on-connect nil)
      (setq cider-repl-history-file "~/.emacs.d/cider-repl-history")
      (setq cider-lein-command "~/bin/lein") ;FIXME: Should be found in path.
      (setq cider-repl-history-size 1000)))

  (use-package cider-decompile
    :defer t
    :ensure cider-decompile)
#+end_src

** Slamhound
#+begin_src emacs-lisp
  (use-package slamhound
    :ensure t
    :defer t
    :commands slamhound)
#+end_src

** Snippets
#+begin_src emacs-lisp
  (use-package clojure-snippets
    :ensure clojure-snippets)
#+end_src

* Cucumber
#+begin_src emacs-lisp
  (use-package feature-mode
    :ensure feature-mode
    :mode (("\.feature$" . feature-mode)))
#+end_src

<* Javascript
#+begin_src emacs-lisp
  (eval-after-load 'js
    '(progn
       (setq js-indent-level 2)
       (define-key js-mode-map (kbd ",") 'self-insert-command)))
       ;; (add-hook
       ;;  'js-mode-hook
       ;;  (lambda ()
       ;;    (push '("function" . "\u0192") prettify-symbols-alist)))
#+end_src
* Coffeescript
#+begin_src emacs-lisp
  (use-package coffee-mode
    :ensure coffee-mode
    :mode (("\\.coffee.erb$" . coffee-mode))

    :init
    (progn
      (defun cnb/coffee-custom ()
        "coffee-mode-hook"
        (make-local-variable 'tab-width)
        (set 'tab-width 2)
        (setq coffee-tab-width 2)
        (setq coffee-debug-mode t)
        (setq js-indent-level 2))

      (add-hook 'coffee-mode-hook #'coffee-custom)))

#+end_src

* Ruby
** Ruby Mode
#+begin_src emacs-lisp
  (use-package ruby-mode
    :ensure ruby-mode
    :mode (("Capfile$"     . ruby-mode)
           ("Gemfile$"     . ruby-mode)
           ("Rakefile$"    . ruby-mode)
           ("Vagrantfile$" . ruby-mode)
           ("\\.gemspec$"  . ruby-mode)
           ("\\.prawn$"    . ruby-mode)
           ("\\.rake$"     . ruby-mode)
           ("\\.rjs$"      . ruby-mode)
           ("\\.ru$"       . ruby-mode)
           ("\\.rb$"       . ruby-mode))

    :init
    (progn
      (defun cnb/ruby-setup ()
        (robe-mode)
        (setq outline-regexp " *\\(def \\|class\\|module\\|describe \\|it \\)")
        (setq imenu-generic-expression '(("Methods"  "^\\( *\\(def\\) +.+\\)" 1)))
        (yard-mode)
        (ruby-block-mode t)
        (ignore-errors (ruby-refactor-mode-launch))))

    :config
    (progn
      ;; I use C-x t for toggling globally
      ;; (define-key ruby-mode-map "\C-xt" nil)

      (add-hook 'ruby-mode-hook #'cnb/ruby-setup)
      (define-key ruby-mode-map (kbd "RET") #'newline-and-indent)))
#+end_src

** Ruby Refactoring
#+begin_src emacs-lisp
  (use-package ruby-refactor
    :ensure ruby-refactor
    :diminish ruby-refactor-mode)
#+end_src

** Ruby Compilation
#+begin_src emacs-lisp
  (use-package ruby-compilation
    :ensure ruby-compilation)
#+end_src

** Ruby Block
#+begin_src emacs-lisp
  (use-package ruby-block
    :ensure ruby-block
    :diminish ruby-block-mode)
#+end_src

** Ruby Hash Syntax
#+BEGIN_SRC emacs-lisp
    (use-package ruby-hash-syntax
      :ensure t
      :config
      (progn
        (bind-key "C-c }" 'ruby-toggle-hash-syntax ruby-mode-map)))
#+END_SRC
** helm-rb
#+BEGIN_SRC emacs-lisp
  (use-package helm-rb
    :defer t
    :ensure t)
#+END_SRC
** RuboCop
#+begin_src emacs-lisp
    (use-package rubocop
      :ensure rubocop
      :diminish rubocop-mode)
#+end_src

** RVM
#+begin_src emacs-lisp
  (use-package rvm
    :ensure rvm
    :config
    (progn
      (rvm-autodetect-ruby)))
#+end_src
** Robe
#+begin_src emacs-lisp
  (use-package helm-robe
    :defer t
    :ensure t)

  (use-package robe
    :ensure robe
    :diminish robe-mode
    :defer t

    :config
    (progn
      (setq robe-completing-read-func 'helm-robe-completing-read)))

#+end_src
** Yard Mode

Font lock for Ruby Yard comments.

#+begin_src emacs-lisp
  (use-package yard-mode
    :ensure t
    :defer t
    :diminish yard-mode)
#+end_src

** Inf-ruby
#+begin_src emacs-lisp
  (use-package inf-ruby
    :ensure inf-ruby)
#+end_src

** Ruby Tools
#+begin_src emacs-lisp
  (use-package ruby-tools
       :ensure t)
#+end_src

** Rails Log Mode
#+BEGIN_SRC emacs-lisp
  (use-package rails-log-mode
    :ensure t)
#+END_SRC
* Foreman
#+BEGIN_SRC emacs-lisp
  (use-package foreman-mode
    :defer t
    :ensure t)
#+END_SRC
* Rspec
#+begin_src emacs-lisp
  (use-package rspec-mode
    :defer t
    :ensure rspec-mode)
#+end_src

* Haskell

#+begin_src emacs-lisp
    (use-package haskell-mode
      :ensure t
      :defer t

      :init
      (progn
        (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
        (add-hook 'haskell-mode-hook #'rainbow-mode)
        (add-hook 'haskell-mode-hook 'interactive-haskell-mode)))
#+end_src

* Lua
#+begin_src emacs-lisp
  (use-package lua-mode
    :defer t
    :ensure t)
#+end_src

* SQL mode.

#+BEGIN_SRC emacs-lisp
(setq sql-input-ring-file-name "~/.emacs.d/sql_history")
(add-hook 'sql-mode-hook
          (lambda ()
            (setq indent-tabs-mode t)))
#+END_SRC
* Emacs Lisp

Put each occurrence of "use-package" into an Imenu section called "Packages".

#+begin_src emacs-lisp
  (defun cnb/elisp-packages ()
    (add-to-list 'imenu-generic-expression '("Packages" "(use-package \\([^)\n]*\\).*$" 1) t))

  (add-hook 'emacs-lisp-mode-hook 'cnb/elisp-packages)

  ;; (add-hook
  ;;  'emacs-lisp-mode-hook
  ;;  (lambda ()
  ;;    (push '("defun" . 402) prettify-symbols-alist)))
#+end_src

* Lisp Like Modes
#+begin_src emacs-lisp
  (defun cnb/imenu-lisp-sections ()
    (setq imenu-prev-index-position-function nil)   ;; FIXME: DO I need this?
    (add-to-list 'imenu-generic-expression '("Sections" "^;;;; \\(.+\\)$" 1) t))

  (setq lisp-modes '(common-lisp-mode
                     clojure-mode
                     emacs-lisp-mode
                     ielm-mode
                     lisp-interaction-mode
                     lisp-mode
                     scheme-mode))

  (dolist (mode lisp-modes)
    (add-hook (intern (format "%s-hook" mode)) #'cnb/imenu-lisp-sections))
#+end_src

* Markup Modes
** YAML
#+begin_src emacs-lisp
  (use-package yaml-mode
    :mode (("\\.yml$" . yaml-mode) ("\\.ya?ml$" . yaml-mode))
    :ensure t
    :defer t

    :config
    (progn
      (add-hook 'yaml-mode-hook
                (lambda ()
                  (define-key yaml-mode-map (kbd "RET") 'newline-and-indent)
                  (electric-indent-local-mode -1)))))

#+end_src

** Markdown
#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure markdown-mode
    :commands markdown-mode
    :mode (("\\.md$" . markdown-mode) ("\\.markdown$" . markdown-mode))

    :init
    (progn
      (add-hook 'markdown-mode-hook #'flyspell-mode)))
#+end_src

#+begin_src emacs-lisp
  (use-package gh-md
    :ensure t)

#+end_src

** HAML
#+begin_src emacs-lisp

  (use-package haml-mode
    :ensure haml-mode

    :mode (("\\.haml\\'"     . haml-mode)
           ("\\.hamlbars\\'" . halm-mode))

    :init
    (progn
      (ignore-errors (robe-mode))
      (local-set-key (kbd "RET") 'newline-and-indent)
      (add-hook
       'haml-mode-hook
       (lambda ()
         (electric-indent-local-mode -1)
         (ruby-tools-mode)
         (rvm-activate-corresponding-ruby)))))
#+end_src

** Handlebars
#+begin_src emacs-lisp
  (use-package handlebars-mode
    :ensure handlebars-mode)
#+end_src
** Web Mode
#+begin_src emacs-lisp
  (use-package web-mode
    :ensure web-mode
    :bind (("C-c C-v" . browse-url-of-buffer))

    :mode (("\\.php\\'"       . web-mode)
           ("\\.phtml\\'"     . web-mode)
           ("\\.tpl\\.php\\'" . web-mode)
           ("\\.jsp\\'"       . web-mode)
           ("\\.as[cp]x\\'"   . web-mode)
           ("\\.erb\\'"       . web-mode)
           ("\\.mustache\\'"  . web-mode)
           ("\\.djhtml\\'"    . web-mode)
           ("\\.html?\\'"     . web-mode)
           ;;("\\.scss\\'"      . web-mode)
           ("\\.css\\'"       . web-mode))

    :init
    (progn
      (setq-default web-mode-markup-indent-offset 2)
      (setq-default web-mode-css-indent-offset 2)
      (setq-default web-mode-code-indent-offset 2)))
#+end_src

** CSS
#+begin_src emacs-lisp
  ;; (setq css-indent-offset 2)
  ;; (add-hook 'css-mode-hook #'rainbow-mode)

#+end_src

** SASS
#+begin_src emacs-lisp
  (use-package scss-mode
    :defer t
    :ensure t)
#+end_src

#+begin_src emacs-lisp
  ;; (use-package flymake-sass
  ;;   :ensure flymake-sass)

  ;; (use-package sass-mode
  ;;   :ensure sass-mode
  ;;   :mode (("\\.sass\\'" . sass-mode)
  ;;          ("\\.scss\\'" . sass-mode))

  ;;   :init
  ;;   (progn
  ;;     (setq scss-compile-at-save nil)
  ;;     (add-hook 'sass-mode-hook #'rainbow-mode)
  ;;     (add-hook 'sass-mode-hook #'flymake-sass-load)))

#+end_src
** Less CSS
#+begin_src emacs-lisp
  ;; (use-package less-css-mode
  ;;   :ensure less-css-mode)
#+end_src

** Text
#+begin_src emacs-lisp
  (add-hook 'text-mode-hook #'turn-on-auto-fill)
  (add-hook 'text-mode-hook #'turn-on-flyspell)

#+end_src
** TeX
#+begin_src emacs-lisp
    (use-package auctex
      :ensure t
      :defer t

      :config
      (progn
        (TeX-global-PDF-mode t))

      :init
      (progn
        ;;(setq-default TeX-master nil)
        (setq TeX-parse-self t)
        (setq TeX-auto-save t)
        (setq TeX-save-query nil)
        ;;(setq TeX-PDF-mode t)

        (add-hook 'LaTeX-mode-hook #'visual-line-mode)
        (add-hook 'LaTeX-mode-hook #'flyspell-mode)
        (add-hook 'LaTeX-mode-hook #'turn-on-reftex)))
        ;;(add-hook 'LaTeX-mode-hook #'nlinum-mode t)))
#+end_src

* Org

Need to use use-package twice to make :pin work See [[https://github.com/jwiegley/use-package/issues/255][bug]].

#+begin_src emacs-lisp
(use-package org
  :pin "gnu")

(use-package org
  :ensure t
  :pin "gnu"

  :bind (("C-c a" . org-agenda)
         ("C-c b" . org-iswitchb)
         ("C-c c" . org-capture)
         ("C-c l" . org-store-link))

  :config
  (progn
    (require 'ob-tangle)
    (setq org-directory "~/Dropbox/org/")
    (setq org-default-notes-file (concat org-directory "refile.org"))
    (setq org-agenda-files
          (list (concat org-directory "personal.org")
                (concat org-directory "kwela.org")))

    ;;(add-hook 'org-mode-hook #'turn-off-auto-fill)
    ;;(add-hook 'org-mode-hook #'nlinum-mode t)

    ;; For jekyll
    (require 'ox-publish)
    (setq org-publish-project-alist
          '(
            ("org-mysite"
             ;; Path to your org files.
             :base-directory "~/src/play/mysite/org"
             :base-extension "org"

             ;; Path to your Jekyll project.
             :publishing-directory "~/src/play/mysite/"
             :recursive t
             :publishing-function org-html-publish-to-html
             :headline-levels 4
             :html-extension "html"
             :body-only t ;; Only export section between <body> </body>
             :with-toc nil)

            ("org-static-mysite"
             :base-directory "~/src/play/mysite/org/"
             :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf\\|php"
             :publishing-directory "~/src/play/mysite/"
             :recursive t
             :publishing-function org-publish-attachment
             :with-toc nil)

            ("mysite" :components ("org-mysite" "org-static-mysite"))))

    (setq org-html-checkbox-type 'unicode)
    (setq org-html-checkbox-types
          '((unicode (on . "<span class=\"task-done\">&#x2611;</span>")
                     (off . "<span class=\"task-todo\">&#x2610;</span>")
                     (trans . "<span class=\"task-in-progress\">[-]</span>"))))

    ;; Capture templates for: TODO tasks, Notes, appointments, phone calls, meetings, and org-protocol
    (setq org-capture-templates
          (quote (("t" "todo" entry (file (concat org-directory "refile.org"))
                   "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
                  ("n" "note" entry (file (concat org-directory "refile.org"))
                   "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)
                  ("p" "Phone call" entry (file (concat org-directory "refile.org"))
                   "* PHONE %? :PHONE:\n%U" :clock-in t :clock-resume t)
                  )))

    (setq org-todo-keywords
          (quote ((sequence "TODO(t)" "STARTED(n)" "|" "DONE(d!/!)")
                  (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE"))))

    (setq org-todo-keyword-faces
          (quote (("TODO" :foreground "red" :weight bold)
                  ("STARTED" :foreground "cyan" :weight bold)
                  ("DONE" :foreground "forest green" :weight bold)
                  ("WAITING" :foreground "orange" :weight bold)
                  ("HOLD" :foreground "magenta" :weight bold)
                  ("CANCELLED" :foreground "forest green" :weight bold)
                  ("PHONE" :foreground "forest green" :weight bold))))

    (setq org-todo-state-tags-triggers
          (quote (("CANCELLED" ("CANCELLED" . t))
                  ("WAITING" ("WAITING" . t))
                  ("HOLD" ("WAITING") ("HOLD" . t))
                  (done ("WAITING") ("HOLD"))
                  ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
                  ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
                  ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))
    ;; Allow refiling to any agenda file.
    (setq org-refile-targets (quote ((nil :maxlevel . 9)
                                     (org-agenda-files :maxlevel . 9))))

    ;; Allow refile to create parent tasks with confirmation
    (setq org-refile-allow-creating-parent-nodes (quote confirm))

    (setq org-treat-S-cursor-todo-selection-as-state-change nil)

    (setq org-enforce-todo-dependencies t)

    (setq org-track-ordered-property-with-tag t)

    ;; Dim blocked tasks
    (setq org-agenda-dim-blocked-tasks t)

    ;; Compact the block agenda view
    (setq org-agenda-compact-blocks t)

    (setq org-deadline-warning-days 15)

    ;; Keep tasks with deadlines on the global todo lists
    (setq org-agenda-todo-ignore-deadlines nil)

    ;; Keep tasks with scheduled dates on the global todo lists
    (setq org-agenda-todo-ignore-scheduled nil)

    ;; Remove completed deadline tasks from the agenda view
    (setq org-agenda-skip-deadline-if-done t)

    ;; Remove completed scheduled tasks from the agenda view
    (setq org-agenda-skip-scheduled-if-done t)

    (setq org-src-fontify-natively t)
    (setq org-src-preserve-indentation t)  ;; Lets fontification work properly
    (setq org-list-description-max-indent 5)

    (setq org-adapt-indentation nil)

    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (ruby . t)
       (sh . t)
       (python . t)
       (sql . t)
       ))))

#+end_src

#+begin_src emacs-lisp
  (use-package deft
    :ensure deft
    :bind (("<f9>" . deft))
    :commands deft

    :config
    (progn
      (setq
       deft-extension "org"
       deft-directory(concat org-directory "deft/")
       deft-text-mode 'org-mode
       deft-extension "org")))

#+end_src

* Other Major Modes
** Crontab
#+begin_src emacs-lisp
  (use-package crontab-mode
    :ensure crontab-mode
    :commands crontab-mode
    :mode (("\\.cron\\(tab\\)?\\'" . crontab-mode)
           ("cron\\(tab\\)?\\."    . crontab-mode))
    )
#+end_src

** Mutt Configuration
#+begin_src emacs-lisp
  (use-package muttrc-mode
    :ensure muttrc-mode
    :defer t
    :mode ("muttrc" . muttrc-mode))

#+end_src
** Mutt Compose
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("/tmp/mutt" . mail-mode))
#+end_src
** Docview
#+begin_src emacs-lisp
  (setq doc-view-resolution 192)  ;; makes PDFs look better
  (setq doc-view-continuous t)
#+end_src
** PDF Tools
#+begin_src emacs-lisp
  (use-package pdf-tools
    :ensure t
    :defer t

    :config
    (progn
      (pdf-tools-install)))
#+end_src

** Terminal
#+begin_src emacs-lisp
  (setq explicit-shell-file-name "/bin/zsh")

  (add-hook
   'term-mode-hook
   (function
    (lambda ()
      (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")
      (make-local-variable 'mouse-yank-at-point)
      (setq mouse-yank-at-point t)
      (make-local-variable 'transient-mark-mode)
      (setq transient-mark-mode nil)

      ;; ya-snippet interferes with term modes tab completion.
      (yas-minor-mode -1)

      (auto-fill-mode -1)
      (setq tab-width 2))))
#+end_src

Close term buffers when terminal is exited.

#+begin_src emacs-lisp
  (defun cnb/term-exec-hook ()
    (let* ((buff (current-buffer))
           (proc (get-buffer-process buff)))
      (set-process-sentinel
       proc
       `(lambda (process event)
          (if (string= event "finished\n")
              (kill-buffer ,buff))))))

  (add-hook 'term-exec-hook #'cnb/term-exec-hook)
#+end_src

** log4j

#+begin_src emacs-lisp
  (use-package log4j-mode
    :defer t
    :ensure t)

#+end_src

* Web Browsers
** Definitions

#+begin_src emacs-lisp
  (setq browse-url-browser-function 'browse-url-firefox)
  ;; (setq browse-url-browser-function 'browse-url-generic
  ;;       browse-url-generic-program "chromium-browser")
#+end_src

** w3m
#+begin_src emacs-lisp
  (setq w3m-default-display-inline-images t)
  (setq w3m-use-cookies t)
  (require 'w3m-load nil t) ;;w3m autoloads
#+end_src

* Open files in external programs

#+begin_src emacs-lisp
  (use-package launch
      :ensure t
      :config (global-launch-mode))
#+end_src

* Tramp
#+begin_src emacs-lisp
  (setq tramp-default-method "ssh")

  ;; Numerous issues with tramp and zsh.
  (eval-after-load 'tramp '(setenv "SHELL" "/bin/bash"))
#+end_src

* Aliases
#+begin_src emacs-lisp
  ;;(defalias 'yes-or-no-p 'y-or-n-p)         ;; Y/N for yes/no in prompts.
  (defalias 'idm 'info-display-manual)
  (defalias 'qrr 'query-replace-regexp)
  (defalias 'dtw 'delete-trailing-whitespace)
#+end_src

* Key Chords
#+begin_src emacs-lisp
  ;; (use-package key-chord
  ;;   :ensure t

  ;;   :init
  ;;   (progn
  ;;     (key-chord-mode +1)))
#+end_src

* Hydra

| Body Color | Head Inherited | Executing NON-HEADS   | Executing HEADS |
|------------+----------------+-----------------------+-----------------|
| amaranth   | red            | Disallow and Continue | Continue        |
| teal       | blue           | Disallow and Continue | Quit            |
| pink       | red            | Allow and Continue    | Continue        |
| red        | red            | Allow and Quit        | Continue        |
| blue       | blue           | Allow and Quit        | Quit            |


| Color    | Toggle                     |
|----------+----------------------------|
| red      |                            |
| blue     | :exit t                    |
| amaranth | :foreign-keys warn         |
| teal     | :foreign-keys warn :exit t |
| pink     | :foreign-keys run          |

** Load package.
#+begin_src emacs-lisp
  (use-package hydra
    :ensure t

    :config
    (progn
      (require 'hydra-examples)
      (hydra-add-font-lock)))
#+end_src

** Help Hydra

#+begin_src emacs-lisp
  (global-set-key
   (kbd "C-c h")

   (defhydra hydra-apropos(:color blue :hint nil)
     "
  Apropos
  ----------------------------
  _a_propos        desc_b_indings
  _c_ommand        _d_ocumentation
  helm-_i_nfo      _l_ibrary
  _v_ariable       _u_ser-option
  _m_an            valu_e_
  _h_elm-apropos

  Help
  ----------------------------
  major mode _b_indings
  _q_uit"
     ("a" apropos)
     ("d" apropos-documentation)
     ("v" apropos-variable)
     ("c" apropos-command)
     ("h" helm-apropos)
     ("i" helm-info-at-point)
     ("l" apropos-library)
     ("m" helm-man-woman)
     ("u" apropos-user-option)
     ("e" apropos-value)
     ("b" helm-descbinds)
     ("q" nil)))
#+end_src

** Global Hydra for Bookmarks.
#+begin_src emacs-lisp
    (global-set-key
     (kbd "<f5> b")
     (defhydra cnb-bookmarks (:color teal)
       "
                                                                                      
       Bookmarks                  Visual Bookmarks                                     Bookmarks  
  

      _l_: list                    _s_: Show in current Buffer
      _b_: goto                    _S_: Show in all buffers
      _d_: delete                  _n_: Next
      ^ ^                          _p_: Previous
      ^ ^                          _t_: Toggle
      ^ ^                          _x_: Set for a Regexp
      ^ ^                          _A_: Cycle in all buffers: %`bm-cycle-all-buffers
      ^ ^                          _T_: Temporary bookmarks:  %`temporary-bookmark-p
      ^ ^                          _r_: Remove all from current buffer
      ^ ^                          _R_: Remove all from ALL buffers
  "
       ("l" bookmark-bmenu-list nil)
       ("b" bookmark-jump       nil)
       ("d" bookmark-delete     nil)

       ("s" bm-show             nil)
       ("S" bm-show-all         nil)
       ("n" bm-next             nil :color red)
       ("p" bm-previous         nil :color red)
       ("t" bm-toggle           nil :color red)
       ("A" (lambda ()
              (interactive)
              (if bm-cycle-all-buffers
                  (setq bm-cycle-all-buffers nil)
                (setq bm-cycle-all-buffers t)))
        nil :color red)
       ("x" bm-bookmark-regexp  nil :color red)
       ("T" (lambda ()
              (interactive)
              (if temporary-bookmark-p
                  (setq temporary-bookmark-p nil)
                (setq temporary-bookmark-p t)))
        nil :color red)
       ("r" bm-remove-all-current-buffer nil :color red)
       ("R" bm-remove-all-all-buffers    nil :color red)

       ("q" nil                 "quit")))
#+end_src

** Global hydra for Rectangle operations.
#+begin_src emacs-lisp
  (defhydra hydra-rectangle (:body-pre (rectangle-mark-mode 1)
                                       :color pink
                                       :post (deactivate-mark))
    "
        rectangle operations

        arrow keys extend region
     "
    ("<left>"   backward-char nil)
    ("<right>"  forward-char  nil)
    ("<up>"     previous-line nil)
    ("<down>"   next-line     nil)
    ("d"        kill-rectangle         "delete")
    ("c"        copy-rectangle-as-kill "copy")
    ("y"        yank-rectangle         "yank")
    ("f"        string-rectangle       "fill")
    ("s"        open-rectangle         "shift")
    ("a"        align-regexp           "align")
    ("C-/"      undo                   "undo")
    ("q"        nil))

  (global-set-key (kbd "C-x SPC") 'hydra-rectangle/body)

#+end_src

** Global hydra for launching.
#+begin_src emacs-lisp
   (global-set-key
    (kbd "<f5> l")
    (defhydra cnb-hydra-launch-functions (:color blue)
      "
                                                                        
                                                                         Launcher 
  
    _a_: ansi-term                      _p_: package manager
    _c_: calculator                     _P_: package manager no fetch
    _d_: ediff buffers                  _t_: top
    _f_: find-dired                     _T_: helm-top
    _i_: helm-find                      _e_: proced
    ^ ^                                 _l_: list-processes
  
   "
      ("a" ansi-term                 nil)
      ("c" calc                      nil)
      ("d" ediff-buffers             nil)
      ("f" find-dired                nil)
      ("i" helm-find                 nil)
      ("p" paradox-list-packages     nil)
      ("P" (list-packages t) nil)
      ("t" proced                    nil)
      ("T" helm-top                  nil)
      ("e" proced                    nil)
      ("l" list-processes            nil)
      ("q" nil                       "cancel")))
#+end_src

** Global hydra for occur/error
#+begin_src emacs-lisp
  (global-set-key
   (kbd "<f5> c")
   (defhydra cnb-hydra-occur-functions ()
     "error/occur functions"
     ("g" first-error "first")
     ("j" next-error "next")
     ("k" previous-error "prev")))
#+end_src

** Global hydra for toggling.
#+begin_src emacs-lisp
(global-set-key
 (kbd "<f5> t")
 (defhydra cnb-hydra-toggle (:color pink)
   "
                                                                                      
                                                                                         Toggle   
  
         _a_ abbrev-mode:       %`abbrev-mode
         _d_ debug-on-error:    %`debug-on-error
         _f_ auto-fill-mode:    %`auto-fill-function
         _l_ nlinum-mode:       %`nlinum-mode
         _r_ readonly-mode:     %`buffer-read-only
         _t_ truncate-lines     %`truncate-lines
         _v_ visual-line-mode:  %`visual-line-mode
         _w_ whitespace-mode:   %`whitespace-mode
         _y_ flycheck           %`flycheck-display-errors-function
         _V_ visible-mode:      %`visible-mode
  
        "
   ("a" abbrev-mode nil)
   ("d" toggle-debug-on-error  nil)
   ("f" auto-fill-mode         nil)
   ("l" nlinum-mode            nil)
   ("r" dired-toggle-read-only nil)
   ("t" toggle-truncate-lines  nil)
   ("v" visual-line-mode       nil)
   ("V" visible-mode           nil)
   ("w" whitespace-mode        nil)
   ("y" (lambda ()
          (interactive)
          (if (equal flycheck-display-errors-function #'flycheck-pos-tip-error-messages)
              (setq flycheck-display-errors-function #'flycheck-display-error-messages)
            (setq flycheck-display-errors-function #'flycheck-pos-tip-error-messages)))
    nil)
   ("q" nil "cancel")))
#+end_src

** Global hydra for window handling
#+begin_src emacs-lisp
    (global-set-key
     (kbd "<f5> w")
     (defhydra cnb-hydra-win-functions (:color amaranth)
       "
                                                                                      
     Move Splitter    Split Window   Ace                                                Windows   
  

     _h_: Left          _x_: Horiz       _s_: Swap
     _l_: Right         _y_: Vert        _d_: Delete
     _j_: Down          _b_: Balance     _m_: Maximize
     _k_: Up
  
    "
       ("h" hydra-move-splitter-left nil)
       ("j" hydra-move-splitter-down nil)
       ("k" hydra-move-splitter-up nil)
       ("l" hydra-move-splitter-right nil)
       ("b" balance-windows nil)

       ("u" winner-undo nil)
       ("r" winner-redo nil)

       ("x" (lambda ()
              (interactive)
              (split-window-below)
              (windmove-down))
        nil)
       ("y" (lambda ()
              (interactive)
              (split-window-right)
              (windmove-right))
        nil)

       ("a" ace-window nil)
       ("s" (lambda () (interactive) (ace-window 4)) nil)
       ("d" (lambda () (interactive) (ace-window 16)) nil)
       ("m" ace-maximize-window nil)

       ("q" nil "quit")))
#+end_src
** Global hydra for outline mode
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-outline (:hint nil)
    "
  ^Hide^             ^Show^           ^Move
  ^^^^^^------------------------------------------------------
  _z_: sublevels     _a_: all         _u_: up
  _t_: body          _e_: entry       _n_: next visible
  _o_: other         _i_: children    _p_: previous visible
  _c_: entry         _k_: branches    _f_: forward same level
  _l_: leaves        _s_: subtree     _b_: backward same level
  _d_: subtree       ^^               _g_: org goto

  "
    ;; Hide
    ("z" hide-sublevels)    ; Hide everything but the top-level headings
    ("t" hide-body)         ; Hide everything but headings (all body lines)
    ("o" hide-other)        ; Hide other branches
    ("c" hide-entry)        ; Hide this entry's body
    ("l" hide-leaves)       ; Hide body lines in this entry and sub-entries
    ("d" hide-subtree)      ; Hide everything in this entry and sub-entries
    ;; Show
    ("a" show-all)          ; Show (expand) everything
    ("e" show-entry)        ; Show this heading's body
    ("i" show-children)     ; Show this heading's immediate child sub-headings
    ("k" show-branches)     ; Show all sub-headings under this heading
    ("s" show-subtree)      ; Show (expand) everything in this heading & below
    ;; Move
    ("u" outline-up-heading)                ; Up
    ("n" outline-next-visible-heading)      ; Next
    ("p" outline-previous-visible-heading)  ; Previous
    ("f" outline-forward-same-level)        ; Forward - same level
    ("b" outline-backward-same-level)       ; Backward - same level
    ("g" org-goto :exit t)
    ("q" nil "quit"))

  (global-set-key (kbd "<f5> o") 'hydra-outline/body)


#+END_SRC

** Global hydra for goto
#+BEGIN_SRC emacs-lisp
(defhydra hydra-goto (:exit t)
  "goto"
  ("c" avy-goto-char "char")
  ("C" avy-goto-char-2 "char-2")
  ("w" avy-goto-word-1 "word")
  ("e" avy-goto-word-0 "word0")
  ("s" avy-goto-subword-1 "subword")
  ("l" goto-line "line")
  ("L" avy-goto-line "avy-line")
  ("i" helm-swoop "helm-swoop"))

(global-set-key (kbd "<f5> g") #'hydra-goto/body)
#+END_SRC
** Global hydra for zooming

#+begin_src emacs-lisp
(defhydra hydra-zoom ()
  "zoom"
  ("+" text-scale-increase "+")
  ("=" text-scale-increase "+") ;; cuz its easier
  ("-" text-scale-decrease "-")
  ("0" (text-scale-adjust 0) "reset")
  ("q" nil "quit" :exit t))

(global-set-key (kbd "<f5> z") #'hydra-zoom/body)
#+end_srcx
** Hydra for controlling foreman processes

#+BEGIN_SRC emacs-lisp
  (defhydra cnb-hydra-foreman (:color blue)
    "
        Root: %(if (projectile-project-p) (projectile-project-root))
                                                                                
                                                                                 Foreman 
      
        _v_: view             _b_: foreman-view-buffer
        _s_: foreman-start    _r_: foreman-restart        _k_: foreman-stop

      "
    ("v" foreman             nil)
    ("b" foreman-view-buffer nil)
    ("s" foreman-start       nil)
    ("r" foreman-restart     nil)
    ("k" foreman-stop        nil)

    ("q" nil "quit"))

  (define-key projectile-rails-mode-map (kbd "<f5> f") 'cnb-hydra-foreman/body)
#+END_SRC
** Markdown mode hydras.
#+begin_src emacs-lisp
  (require 'markdown-mode)

  (define-key markdown-mode-map (kbd "<f5> m")
    (defhydra cnb-md-hydra (:color blue)
      "markdown"
      ("b" gh-md-render-buffer "render buffer via github")))
#+end_src

** Dired Hydras
   #+begin_src emacs-lisp
(defhydra hydra-dired-sort (:exit t :foreign-keys warn)
  "
                                                                                  
                                                                                   Dired Sort 
              
                _n_: name                           _N_: name rev
                _e_: ext                            _E_: ext rev
                _s_: size                           _S_: size rev
                _t_: last modified                  _T_: last modified rev
              
               "
  ("s" (lambda ()
         (interactive)
         (dired-sort-other (concat dired-listing-switches " -S")))
   nil)
  ("S" (lambda ()
         (interactive)
         (dired-sort-other (concat dired-listing-switches " -rS")))
   nil)

  ("e" (lambda ()
         (interactive)
         (dired-sort-other (concat dired-listing-switches " -X")))
   nil)
  ("E" (lambda ()
         (interactive)
         (dired-sort-other (concat dired-listing-switches " -rX")))
   nil)

  ("t" (lambda ()
         (interactive)
         (dired-sort-other (concat dired-listing-switches " -t")))
   nil)
  ("T" (lambda ()
         (interactive)
         (dired-sort-other (concat dired-listing-switches " -rt")))
   nil)

  ("n" (lambda ()
         (interactive)
         (dired-sort-other dired-listing-switches))
   nil)
  ("N" (lambda ()
         (interactive)
         (dired-sort-other (concat dired-listing-switches " -r")))
   nil)

  ("q" nil                       "cancel"))

(define-key dired-mode-map (kbd "s") 'hydra-dired-sort/body)
   #+end_src

** Projectile mode hydras
#+begin_src emacs-lisp
    (define-key
      projectile-mode-map
      (kbd "<f5> p")
      (defhydra cnb-hydra-projectile (:color teal)
        "
       Root: %(if (projectile-project-p) (projectile-project-root))
                                                                                                      
       Files                           Buffers                   Search               Projects         Projectile 
  

       _f_: find                         _i_: ibuffer                _s_: search (ag)       _p_: Switch
       _F_: find in other window         _b_: switch to  buffer      _o_: multi-occur       _x_: cleanup
       _d_: find in directory            _k_: kill all buffers       _u_: query-replace     _I_: info
       _r_: recent files                 ^    ^                      _T_: regenerate tags
       _h_: project home                 ^    ^                      _t_: search tags
  
       "
        ("f" projectile-find-file                        nil)
        ("F" projectile-find-file-other-window           nil)
        ("d" projectile-find-file-in-directory           nil)
        ("r" projectile-recentf                          nil)
        ("h" projectile-dired                            nil)

        ("i" projectile-ibuffer                          nil)
        ("b" projectile-switch-to-buffer                 nil)
        ("k" projectile-kill-buffers                     nil :color blue)

        ("s" projectile-ag                               nil)
        ("o" projectile-multi-occur                      nil)
        ("u" projectile-replace                          nil)
        ("t" projectile-find-tag                         nil)
        ("T" projectile-regenerate-tags                  nil :color red)

        ("p" projectile-switch-project                   nil)
        ("x" projectile-cleanup-known-projects           nil :color red)
        ("I" projectile-project-info                     nil)

        ("q"   nil                                       "quit" :color blue)))
#+end_src

** Rails hydras
#+begin_src emacs-lisp
  (define-key
    projectile-rails-mode-map
    (kbd "<f5> r")
    (defhydra cnb-hydra-projectile-rails (:color teal)
      "
      Root: %(if (projectile-project-p) (projectile-project-root))
                                                                                       
                                                                                        Rails - Find 
  

           _a_: authorizer                 _m_: model                _c_: controller
           _A_: current authorizer         _M_: current model        _C_: current controller
           _d_: decorator                  _v_: view
           _D_: current decorator          _V_: current view
                                                                                       
                                                                                        Rails - Run  
  

            _i_: irb console              _rr_: rake
                                                                                       
                                                                                        Rails - Logs 
  

           _ld_: development               _lp_: production          _lt_: test

    "
      ("a" cnb/projectile-rails-find-authorizer         nil)
      ("A" cnb/projectile-rails-find-current-authorizer nil)
      ("c" projectile-rails-find-controller             nil)
      ("C" projectile-rails-find-current-controller     nil)
      ("d" cnb/projectile-rails-find-decorator          nil)
      ("D" cnb/projectile-rails-find-current-decorator  nil)
      ("m" projectile-rails-find-model                  nil)
      ("M" projectile-rails-find-current-model          nil)
      ("v" projectile-rails-find-view                   nil)
      ("V" projectile-rails-find-current-view           nil)

      ("ld" rails-log-show-development nil)
      ("lp" rails-log-show-production  nil)
      ("lt" rails-log-show-test        nil)

      ("rs" projectile-rails-server         nil)
      ("i" projectile-rails-console         nil)
      ("rr" projectile-rails-find-rake-task nil :color red)

      ("q" nil "quit" :color blue)))
#+end_src

** Smartparens hydras
#+BEGIN_SRC emacs-lisp
  (define-key smartparens-mode-map (kbd "<f5> s")
    (defhydra hydra-learn-sp (:hint nil)
      "
                                                                                    
                                                                                     Smartparens 

    _B_ backward-sexp            
    _F_ forward-sexp               _s_ splice-sexp
    _L_ backward-down-sexp         _df_ splice-sexp-killing-forward
    _H_ backward-up-sexp           _db_ splice-sexp-killing-backward
  ^^                         _da_ splice-sexp-killing-around
    _k_ down-sexp                
    _j_ up-sexp                    _C-s_ select-next-thing-exchange
  ^^                         _C-p_ select-previous-thing
    _n_ next-sexp                  _C-n_ select-next-thing
    _p_ previous-sexp            
    _a_ beginning-of-sexp          _C-f_ forward-symbol
    _z_ end-of-sexp                _C-b_ backward-symbol
  ^^                          
    _t_ transpose-sexp             _c_ convolute-sexp
  ^^                            _g_ absorb-sexp
    _x_ delete-char                _q_ emit-sexp
    _dw_ kill-word               
    _dd_ kill-sexp                 _,b_ extract-before-sexp
  ^^                            _,a_ extract-after-sexp
    _S_ unwrap-sexp              
  ^^                            _AP_ add-to-previous-sexp
    _C-h_ forward-slurp-sexp       _AN_ add-to-next-sexp
    _C-l_ forward-barf-sexp      
    _C-S-h_ backward-slurp-sexp    _ join-sexp
    _C-S-l_ backward-barf-sexp     _|_ split-sexp
  "
      ;; TODO: Use () and [] - + * | <space>
      ("B" sp-backward-sexp );; similiar to VIM b
      ("F" sp-forward-sexp );; similar to VIM f
      ;;
      ("L" sp-backward-down-sexp )
      ("H" sp-backward-up-sexp )
      ;;
      ("k" sp-down-sexp ) ; root - towards the root
      ("j" sp-up-sexp )
      ;;
      ("n" sp-next-sexp )
      ("p" sp-previous-sexp )
      ;; a..z
      ("a" sp-beginning-of-sexp )
      ("z" sp-end-of-sexp )
      ;;
      ("t" sp-transpose-sexp )
      ;;
      ("x" sp-delete-char )
      ("dw" sp-kill-word )
      ;;("ds" sp-kill-symbol ) ;; Prefer kill-sexp
      ("dd" sp-kill-sexp )
      ;;("yy" sp-copy-sexp ) ;; Don't like it. Pref visual selection
      ;;
      ("S" sp-unwrap-sexp ) ;; Strip!
      ;;("wh" sp-backward-unwrap-sexp ) ;; Too similar to above
      ;;
      ("C-h" sp-forward-slurp-sexp )
      ("C-l" sp-forward-barf-sexp )
      ("C-S-h" sp-backward-slurp-sexp )
      ("C-S-l" sp-backward-barf-sexp )
      ;;
      ;;("C-[" (bind (sp-wrap-with-pair "[")) ) ;;FIXME
      ;;("C-(" (bind (sp-wrap-with-pair "(")) )
      ;;
      ("s" sp-splice-sexp )
      ("df" sp-splice-sexp-killing-forward )
      ("db" sp-splice-sexp-killing-backward )
      ("da" sp-splice-sexp-killing-around )
      ;;
      ("C-s" sp-select-next-thing-exchange )
      ("C-p" sp-select-previous-thing )
      ("C-n" sp-select-next-thing )
      ;;
      ("C-f" sp-forward-symbol )
      ("C-b" sp-backward-symbol )
      ;;
      ;;("C-t" sp-prefix-tag-object)
      ;;("H-p" sp-prefix-pair-object)
      ("c" sp-convolute-sexp )
      ("g" sp-absorb-sexp )
      ("q" sp-emit-sexp )
      ;;
      (",b" sp-extract-before-sexp )
      (",a" sp-extract-after-sexp )
      ;;
      ("AP" sp-add-to-previous-sexp );; Difference to slurp?
      ("AN" sp-add-to-next-sexp )
      ;;
      ("_" sp-join-sexp ) ;;Good
      ("|" sp-split-sexp )))
#+END_SRC
* ws-butler
#+begin_src emacs-lisp
  (use-package ws-butler
    :ensure t
    :config
    (progn
      (add-hook 'css-mode-hook 'ws-butler-mode)
      (add-hook 'ruby-mode-hook 'ws-butler-mode)))
 #+end_src

* Session

Remember current position in file.

#+begin_src emacs-lisp
    (use-package saveplace
      ;;:demand

      :init
      (progn
        (save-place-mode)
        (setq save-place-forget-unreadable-files nil)  ;; performance
        (setq save-place-file (expand-file-name "places" user-emacs-directory))))
#+end_src

Remember open buffers.

#+begin_src emacs-lisp
  ;; Problems with projectile mode. Refuses to load desktop.
  ;; (use-package desktop
  ;;   :demand t

  ;;   :init
  ;;   (progn
  ;;     (desktop-save-mode)
  ;;     ;;(setq desktop-restore-frames nil) ;; Probs with emacsclient
  ;;     (setq desktop-load-locked-desktop nil)
  ;;     (setq desktop-restore-eager 10)   ;; Open first X immed then rest in background

  ;;     (setq desktop-globals-to-save (delete 'tags-file-name desktop-globals-to-save))
  ;;     (setq desktop-globals-to-save (delete 'tags-table-list desktop-globals-to-save)))

  ;;   :config
  ;;   (progn
  ;;     (add-to-list 'desktop-modes-not-to-save 'dired-mode)))
#+end_src

Remember command and search history.

#+begin_src emacs-lisp
  (use-package savehist
    :init
    (progn
      (setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
      (savehist-mode)
      (setq history-delete-duplicates t)
      (setq savehist-save-minibuffer-history t)))
#+end_src

* Games
#+BEGIN_SRC emacs-lisp
  (use-package 2048-game
    :defer t
    :ensure t)

  (use-package pacmacs
    :defer t
    :ensure t)

#+END_SRC
* Finalisation

Try to fix "org-export-as: Wrong number of arguments: #[(templates)"
error when exporting from org to HTML, PDF etc.
#+begin_src emacs-lisp
  (org-reload)
#+end_src
* Put somewhere

#+begin_src emacs-lisp
  ;; From http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html
  (defun cnb/narrow-or-widen-dwim (p)
    "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
  Intelligently means: region, subtree, or defun, whichever applies
  first.

  With prefix P, don't widen, just narrow even if buffer is already
  narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning) (region-end)))
          ((derived-mode-p 'org-mode) (org-narrow-to-subtree))
          (t (narrow-to-defun))))
#+end_src

#+begin_src emacs-lisp
(use-package htmlize
  :defer t
  :ensure t)

(setq compilation-scroll-output t)
;;(setq compilation-scroll-output 'first-error)

(setq scroll-preserve-screen-position 'always)


;;(setq redisplay-dont-pause t) obsolete in 24.5

(setq apropos-do-all t)
(auto-image-file-mode)

(set-default 'imenu-auto-rescan t)

(setenv "PAGER" "cat")

(setq echo-keystrokes 1.0)

(setq shift-select-mode t
      mouse-yank-at-point t
      ;;save-interprogram-paste-before-kill t
      require-final-newline t)

#+end_src

#+begin_src emacs-lisp
(use-package visible-mode
  :bind ("H-v" . visible-mode))
#+end_src

#+begin_src emacs-lisp
;; (use-package ack-and-a-half
;;   :ensure ack-and-a-half)

#+end_src

* Do I need these?

#+begin_src emacs-lisp
  ;; (setq truncate-partial-width-windows nil)
  ;; (electric-layout-mode)
  ;; (setq completion-cycle-threshold 5)
  ;; How often do I key a comma without a trailing space?
  ;; Commented out as I just can't stop pressing the space-bar
  ;; (global-set-key (kbd ",") (lambda() (interactive) (insert ", ")))
  ;; (use-package findr
  ;;   :ensure t)

  ;; (use-package inflections
  ;;   :ensure t)

  ;; (use-package jump
  ;;   :ensure t)

#+end_src
